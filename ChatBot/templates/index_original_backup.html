<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ChatBot Assistant</title>
    <!-- Marked.js for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js for code syntax -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- jsPDF and html2canvas for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <!-- Sidebar Toggle (Mobile) -->
    <div class="sidebar-toggle" id="sidebarToggle">
        ‚ò∞
    </div>
    
    <div class="main-wrapper">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h3>üí¨ L·ªãch s·ª≠ Chat</h3>
                <button class="new-chat-btn" id="newChatBtn">+ M·ªõi</button>
            </div>
            <div style="padding: 10px; font-size: 11px; color: #888; border-bottom: 1px solid #333;">
                <span id="storageInfo">ƒêang t√≠nh...</span>
            </div>
            <div class="chat-list" id="chatList">
                <!-- Chat items will be dynamically added here -->
            </div>
        </div>
        
        <!-- Main Chat Container -->
        <div class="container">
        <div class="header">
            <h1>ü§ñ AI ChatBot Assistant</h1>
            <p>H·ªó tr·ª£ t√¢m l√Ω, t√¢m s·ª± v√† gi·∫£i ph√°p ƒë·ªùi s·ªëng</p>
        </div>
        
        <div class="controls">
            <div class="control-group"> 
                <label>
                    Model:
                    <select id="modelSelect">
                        <option value="gemini">Gemini (Google) - FREE</option>
                        <option value="openai">GPT-4o-mini (OpenAI)</option>
                        <option value="deepseek">DeepSeek (R·∫ª nh·∫•t)</option>
                        <option value="qwen">Qwen1.5b (Alibaba Cloud)</option>
                        <option value="bloomvn">BloomVN-8B API (Ti·∫øng Vi·ªát) - FREE</option>
                        <optgroup label="üñ•Ô∏è Local Models (FREE - No Internet)">
                            <option value="qwen1.5-local">üñ•Ô∏è Qwen1.5-1.8B Local</option>
                            <option value="bloomvn-local">üñ•Ô∏è BloomVN-8B Local</option>
                            <option value="qwen2.5-local">üñ•Ô∏è Qwen2.5-14B Local ‚≠ê</option>
                        </optgroup>
                    </select>
                </label>
                
                <label>
                    Ch·∫ø ƒë·ªô:
                    <select id="contextSelect">
                        <option value="casual">Tr√≤ chuy·ªán vui v·∫ª</option>
                        <option value="psychological">T√¢m l√Ω - T√¢m s·ª±</option>
                        <option value="lifestyle">Gi·∫£i ph√°p ƒë·ªùi s·ªëng</option>
                        <option value="programming">üíª H·ªó tr·ª£ l·∫≠p tr√¨nh</option>
                    </select>
                </label>
                
                <div class="checkbox-container" id="deepThinkingContainer">
                    <input type="checkbox" id="deepThinkingCheck">
                    <label for="deepThinkingCheck">üß† Suy lu·∫≠n s√¢u</label>
                </div>
                
                <button class="download-btn" id="downloadBtn" title="T·∫£i xu·ªëng l·ªãch s·ª≠ chat">
                    üì• T·∫£i chat
                </button>
                <button class="image-gen-btn" id="imageGenBtn" title="T·∫°o ·∫£nh b·∫±ng AI">
                    üé® T·∫°o ·∫£nh
                </button>
                <button class="memory-btn" id="memoryBtn" title="Qu·∫£n l√Ω b·ªô nh·ªõ AI">
                    üß† AI h·ªçc t·∫≠p
                </button>
                <button class="dark-mode-toggle" id="darkModeBtn" title="Toggle Dark Mode">üåô</button>
                <button id="clearBtn">üóëÔ∏è X√≥a l·ªãch s·ª≠</button>
            </div>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message assistant">
                <div class="message-content">
                    <div>Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa b·∫°n. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay? üòä</div>
                    <div class="message-info">Gemini ‚Ä¢ Tr√≤ chuy·ªán vui v·∫ª</div>
                </div>
            </div>
        </div>
        
        <!-- Memory Panel (hidden by default) -->
        <div class="memory-panel" id="memoryPanel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <strong>üìö B√†i h·ªçc ƒë√£ l∆∞u (ch·ªçn ƒë·ªÉ k√≠ch ho·∫°t):</strong>
                <button class="new-chat-btn" id="saveMemoryBtn" style="padding: 5px 12px; font-size: 12px;">
                    üíæ L∆∞u chat n√†y
                </button>
            </div>
            <div id="memoryList">
                <!-- Memory items will be loaded here -->
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span>ƒêang suy nghƒ©...</span>
        </div>
        
        <div class="input-container">
            <div class="input-tools">
                <button class="tool-btn" id="googleSearchBtn" title="T√¨m ki·∫øm Google">
                    üîç Search
                </button>
                <button class="tool-btn" id="githubBtn" title="K·∫øt n·ªëi GitHub">
                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    GitHub
                </button>
                <button class="tool-btn" id="imageGenToolBtn" title="T·∫°o ·∫£nh t·ª´ text prompt (Text2Img)">
                    üé® Text2Img
                </button>
                <button class="tool-btn" id="img2imgToolBtn" title="T·∫°o ·∫£nh t·ª´ upload (Img2Img)">
                    üñºÔ∏è Img2Img
                </button>
                <label class="file-label" title="Upload t√†i li·ªáu (txt, pdf, doc, code files)">
                    üìé Files
                    <input type="file" class="file-input" id="fileInput" accept=".txt,.pdf,.doc,.docx,.json,.py,.js,.html,.css" multiple>
                </label>
            </div>
            <div class="file-list" id="fileList">
                <!-- Uploaded files will appear here -->
            </div>
            <div class="input-group">
                <textarea 
                    id="messageInput" 
                    placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n... (Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng, Ctrl+V ƒë·ªÉ paste)"
                    rows="1"
                ></textarea>
                <button id="sendBtn">G·ª≠i</button>
            </div>
        </div>
        </div> <!-- Close container -->
    </div> <!-- Close main-wrapper -->
    
    <script>
        // DOM elements - DECLARE FIRST
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const clearBtn = document.getElementById('clearBtn');
        const modelSelect = document.getElementById('modelSelect');
        const contextSelect = document.getElementById('contextSelect');
        const loading = document.getElementById('loading');
        const googleSearchBtn = document.getElementById('googleSearchBtn');
        const githubBtn = document.getElementById('githubBtn');
        const imageGenToolBtn = document.getElementById('imageGenToolBtn');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const deepThinkingCheck = document.getElementById('deepThinkingCheck');
        const darkModeBtn = document.getElementById('darkModeBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const memoryBtn = document.getElementById('memoryBtn');
        const memoryPanel = document.getElementById('memoryPanel');
        const saveMemoryBtn = document.getElementById('saveMemoryBtn');
        const memoryListEl = document.getElementById('memoryList');
        
        let activeTools = new Set();
        let uploadedFiles = []; // Changed from single file to array
        let conversationActive = false;
        let chatHistory = []; // Store full chat history for download
        let selectedMemories = new Set(); // Store selected memory IDs
        let allMemories = []; // Store all available memories
        
        // Chat Session Management
        let currentChatId = null;
        let chatSessions = {};
        
        class ChatSession {
            constructor(id) {
                this.id = id;
                this.title = 'Cu·ªôc tr√≤ chuy·ªán m·ªõi';
                this.messages = [];
                this.createdAt = new Date();
                this.updatedAt = new Date();
            }
        }
        
        // Load sessions from localStorage
        function loadSessions() {
            const saved = localStorage.getItem('chatSessions');
            if (saved) {
                const parsed = JSON.parse(saved);
                chatSessions = {};
                Object.keys(parsed).forEach(id => {
                    const session = parsed[id];
                    chatSessions[id] = session;
                    chatSessions[id].createdAt = new Date(session.createdAt);
                    chatSessions[id].updatedAt = new Date(session.updatedAt);
                });
            }
            
            // If no sessions exist, create first one
            if (Object.keys(chatSessions).length === 0) {
                newChat();
            } else {
                // Load the most recent chat
                const sortedIds = Object.keys(chatSessions).sort((a, b) => 
                    chatSessions[b].updatedAt - chatSessions[a].updatedAt
                );
                currentChatId = sortedIds[0];
                loadChat(currentChatId);
            }
            
            renderChatList();
        }
        
        // Compress base64 images to reduce storage size
        function compressBase64Image(base64String, quality = 0.6) {
            return new Promise((resolve) => {
                // If not a base64 image, return as-is
                if (!base64String || !base64String.includes('data:image')) {
                    resolve(base64String);
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size (max 800x800 for storage)
                    const maxSize = 800;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxSize || height > maxSize) {
                        if (width > height) {
                            height = (height / width) * maxSize;
                            width = maxSize;
                        } else {
                            width = (width / height) * maxSize;
                            height = maxSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Compress to JPEG with quality
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = function() {
                    resolve(base64String); // Return original if error
                };
                img.src = base64String;
            });
        }
        
        // Compress all images in HTML content
        async function compressImagesInHTML(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const images = doc.querySelectorAll('img[src^="data:image"]');
            
            for (let img of images) {
                const compressed = await compressBase64Image(img.src, 0.6);
                img.src = compressed;
            }
            
            return doc.documentElement.outerHTML;
        }
        
        // Save sessions to localStorage
        async function saveSessions() {
            try {
                // First, try to compress images in current session if it has images
                if (currentChatId && chatSessions[currentChatId] && chatSessions[currentChatId].messages) {
                    const messages = chatSessions[currentChatId].messages;
                    const hasImages = messages.some(msg => typeof msg === 'string' && msg.includes('data:image'));
                    
                    if (hasImages) {
                        console.log('[STORAGE] Compressing images in current session...');
                        const compressedMessages = [];
                        for (let msg of messages) {
                            if (typeof msg === 'string' && msg.includes('data:image')) {
                                compressedMessages.push(await compressImagesInHTML(msg));
                            } else {
                                compressedMessages.push(msg);
                            }
                        }
                        chatSessions[currentChatId].messages = compressedMessages;
                    }
                }
                
                const sessionsData = JSON.stringify(chatSessions);
                const sizeInMB = (new Blob([sessionsData]).size / 1024 / 1024).toFixed(2);
                
                console.log(`[STORAGE] Saving ${Object.keys(chatSessions).length} sessions, size: ${sizeInMB}MB`);
                
                localStorage.setItem('chatSessions', sessionsData);
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    console.error('[STORAGE] Quota exceeded! Cleaning up old sessions...');
                    
                    // Show error to user
                    alert('‚ö†Ô∏è B·ªô nh·ªõ ƒë·∫ßy!\n\nƒêang t·ª± ƒë·ªông x√≥a c√°c chat c≈© ƒë·ªÉ gi·∫£i ph√≥ng dung l∆∞·ª£ng...');
                    
                    // Keep only the 5 most recent sessions
                    const sortedIds = Object.keys(chatSessions).sort((a, b) => 
                        chatSessions[b].updatedAt - chatSessions[a].updatedAt
                    );
                    
                    const idsToKeep = sortedIds.slice(0, 5);
                    const newSessions = {};
                    
                    idsToKeep.forEach(id => {
                        newSessions[id] = chatSessions[id];
                    });
                    
                    chatSessions = newSessions;
                    
                    // Try saving again
                    try {
                        localStorage.setItem('chatSessions', JSON.stringify(chatSessions));
                        console.log(`[STORAGE] Successfully cleaned up. Kept ${idsToKeep.length} sessions.`);
                        renderChatList();
                        
                        // If current chat was deleted, switch to most recent
                        if (!chatSessions[currentChatId]) {
                            switchChat(idsToKeep[0]);
                        }
                    } catch (e2) {
                        console.error('[STORAGE] Still failed after cleanup:', e2);
                        alert('‚ùå Kh√¥ng th·ªÉ l∆∞u chat.\n\nVui l√≤ng:\n1. Export chat quan tr·ªçng\n2. X√≥a b·ªõt chat c≈©\n3. Ho·∫∑c clear localStorage');
                    }
                } else {
                    console.error('[STORAGE] Error saving sessions:', e);
                }
            }
            // Update storage display after save
            updateStorageDisplay();
        }
        
        // Update storage usage display
        function updateStorageDisplay() {
            try {
                const sessionsData = JSON.stringify(chatSessions);
                const sizeInMB = (new Blob([sessionsData]).size / 1024 / 1024).toFixed(2);
                const maxSizeMB = 200; // Increased limit for 4K images
                const percentage = ((sizeInMB / maxSizeMB) * 100).toFixed(0);
                
                const storageInfo = document.getElementById('storageInfo');
                const color = percentage > 80 ? '#ff4444' : percentage > 50 ? '#ffa500' : '#4CAF50';
                
                storageInfo.innerHTML = `
                    <span style="color: ${color};">üìä L∆∞u tr·ªØ: ${sizeInMB}MB / ${maxSizeMB}MB (${percentage}%)</span>
                    <button onclick="manualCleanup()" style="
                        margin-left: 10px;
                        padding: 2px 6px;
                        font-size: 10px;
                        background: #444;
                        border: 1px solid #666;
                        border-radius: 3px;
                        color: #fff;
                        cursor: pointer;
                    " title="X√≥a c√°c chat c≈© (gi·ªØ l·∫°i 5 g·∫ßn nh·∫•t)">üóëÔ∏è D·ªçn d·∫πp</button>
                `;
            } catch (e) {
                console.error('[STORAGE] Error updating storage display:', e);
            }
        }
        
        // Manual cleanup function
        function manualCleanup() {
            const sessionCount = Object.keys(chatSessions).length;
            if (sessionCount <= 5) {
                alert('Ch·ªâ c√≤n ' + sessionCount + ' chat, kh√¥ng c·∫ßn d·ªçn d·∫πp.');
                return;
            }
            
            if (confirm(`X√≥a c√°c chat c≈© v√† ch·ªâ gi·ªØ l·∫°i 5 chat g·∫ßn nh·∫•t?\nHi·ªán t·∫°i c√≥ ${sessionCount} chat.`)) {
                const sortedSessions = Object.entries(chatSessions)
                    .sort((a, b) => new Date(b[1].updatedAt) - new Date(a[1].updatedAt))
                    .slice(0, 5);
                
                const oldCount = sessionCount;
                chatSessions = Object.fromEntries(sortedSessions);
                
                // Update current chat if it was deleted
                if (!chatSessions[currentChatId]) {
                    currentChatId = sortedSessions[0][0];
                    loadChat(currentChatId);
                }
                
                saveSessions(); // This will also update storage display
                renderChatList();
                
                alert(`‚úÖ ƒê√£ x√≥a ${oldCount - 5} chat c≈©!\nGi·ªØ l·∫°i 5 chat g·∫ßn nh·∫•t.`);
            }
        }
        
        // Create new chat session
        function newChat() {
            // Save current chat before creating new one
            if (currentChatId && chatSessions[currentChatId]) {
                chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                chatSessions[currentChatId].updatedAt = new Date();
            }
            
            const id = 'chat_' + Date.now();
            const session = new ChatSession(id);
            chatSessions[id] = session;
            currentChatId = id;
            
            // Clear chat container - start clean without welcome message
            chatContainer.innerHTML = '';
            
            chatHistory = [];
            saveSessions();
            renderChatList();
        }
        
        // Switch to existing chat
        function switchChat(chatId) {
            if (chatId === currentChatId) return;
            
            // Save current chat before switching
            if (currentChatId && chatSessions[currentChatId]) {
                chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                chatSessions[currentChatId].updatedAt = new Date();
            }
            
            currentChatId = chatId;
            loadChat(chatId);
            saveSessions();
            renderChatList();
            
            // Close sidebar on mobile
            if (window.innerWidth <= 768) {
                document.getElementById('sidebar').classList.remove('show');
            }
        }
        
        // Load chat from session
        function loadChat(chatId) {
            const session = chatSessions[chatId];
            if (!session) return;
            
            if (session.messages.length > 0) {
                chatContainer.innerHTML = session.messages.join('');
                
                // Re-attach event listeners for edit and copy buttons
                chatContainer.querySelectorAll('.edit-message-btn').forEach(btn => {
                    const messageDiv = btn.closest('.message');
                    const textContent = messageDiv.querySelector('.message-text')?.textContent || '';
                    btn.onclick = function() {
                        showEditForm(messageDiv, textContent);
                    };
                });
                
                chatContainer.querySelectorAll('.copy-message-btn').forEach(btn => {
                    const messageDiv = btn.closest('.message');
                    const textContent = messageDiv.querySelector('.message-text')?.textContent || '';
                    btn.onclick = function() {
                        copyMessageToClipboard(textContent, btn);
                    };
                });
                
                chatContainer.querySelectorAll('.copy-table-btn').forEach(btn => {
                    const table = btn.previousElementSibling;
                    if (table && table.tagName === 'TABLE') {
                        btn.onclick = function() {
                            copyTableToClipboard(table, btn);
                        };
                    }
                });
                
                // Re-attach event listeners for history buttons
                chatContainer.querySelectorAll('.message-history-btn').forEach(btn => {
                    const messageDiv = btn.closest('.message');
                    const messageId = messageDiv.dataset.messageId;
                    if (messageId) {
                        btn.onclick = function() {
                            showMessageHistory(messageId);
                        };
                    }
                });
            } else {
                // Start with empty chat
                chatContainer.innerHTML = '';
            }
            
            // Rebuild chatHistory for download
            chatHistory = [];
            Array.from(chatContainer.children).forEach(msgEl => {
                const isUser = msgEl.classList.contains('user');
                const content = msgEl.querySelector('.message-text')?.textContent || '';
                chatHistory.push({
                    role: isUser ? 'user' : 'assistant',
                    content: content
                });
            });
            
            // Make images clickable after loading chat
            setTimeout(() => {
                if (window.makeImagesClickable) {
                    console.log('[Image Preview] Making images clickable after loading chat');
                    window.makeImagesClickable();
                }
            }, 200);
        }
        
        // Delete chat session
        function deleteChat(chatId, event) {
            event.stopPropagation();
            
            if (Object.keys(chatSessions).length === 1) {
                alert('Kh√¥ng th·ªÉ x√≥a cu·ªôc tr√≤ chuy·ªán cu·ªëi c√πng!');
                return;
            }
            
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a cu·ªôc tr√≤ chuy·ªán n√†y?')) {
                return;
            }
            
            delete chatSessions[chatId];
            
            // If deleting current chat, switch to another
            if (chatId === currentChatId) {
                const remainingIds = Object.keys(chatSessions);
                if (remainingIds.length > 0) {
                    switchChat(remainingIds[0]);
                } else {
                    newChat();
                }
            }
            
            saveSessions();
            renderChatList();
        }
        
        // Generate title using Gemini
        async function generateTitle(firstMessage) {
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Generate a concise 3-5 word Vietnamese title for this conversation. Only return the title, nothing else: "${firstMessage.substring(0, 100)}"`,
                        model: 'gemini',
                        context: 'casual',
                        tools: [],
                        deep_thinking: false
                    })
                });
                
                const data = await response.json();
                if (data.response) {
                    return data.response.trim().replace(/['"]/g, '');
                }
            } catch (error) {
                console.error('Failed to generate title:', error);
            }
            
            // Fallback: use first few words
            return firstMessage.substring(0, 30) + (firstMessage.length > 30 ? '...' : '');
        }
        
        // Render chat list in sidebar
        function renderChatList() {
            const chatList = document.getElementById('chatList');
            const sortedChats = Object.keys(chatSessions).sort((a, b) => 
                chatSessions[b].updatedAt - chatSessions[a].updatedAt
            );
            
            chatList.innerHTML = sortedChats.map(id => {
                const session = chatSessions[id];
                const isActive = id === currentChatId;
                const preview = session.messages.length > 0 
                    ? (session.messages[1] || session.messages[0]).replace(/<[^>]*>/g, '').substring(0, 50) + '...'
                    : 'Ch∆∞a c√≥ tin nh·∫Øn';
                
                return `
                    <div class="chat-item ${isActive ? 'active' : ''}" onclick="switchChat('${id}')">
                        <div class="chat-item-title">${session.title}</div>
                        <div class="chat-item-preview">${preview}</div>
                        <div class="chat-item-footer">
                            <span class="chat-item-time">${formatTimestamp(session.updatedAt)}</span>
                            <button class="chat-delete-btn" onclick="deleteChat('${id}', event)" title="X√≥a">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Sidebar toggle for mobile
        document.getElementById('sidebarToggle').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('show');
        });
        
        document.getElementById('newChatBtn').addEventListener('click', newChat);
        
        // Initialize sessions on page load
        loadSessions();
        
        // Update storage display on page load
        updateStorageDisplay();
        
        // Check local models status
        checkLocalModelsStatus();
        
        async function checkLocalModelsStatus() {
            try {
                const response = await fetch('/api/local-models-status');
                const data = await response.json();
                
                if (data.available && data.models) {
                    console.log('Local models status:', data.models);
                    
                    // Disable options for unavailable models
                    const modelSelect = document.getElementById('modelSelect');
                    const options = modelSelect.querySelectorAll('option');
                    
                    options.forEach(option => {
                        const value = option.value;
                        if (value.endsWith('-local')) {
                            const modelKey = value === 'bloomvn-local' ? 'bloomvn' : 
                                            value === 'qwen1.5-local' ? 'qwen1.5' :
                                            value === 'qwen2.5-local' ? 'qwen2.5' : null;
                            
                            if (modelKey && data.models[modelKey]) {
                                if (!data.models[modelKey].available) {
                                    option.disabled = true;
                                    option.textContent += ' (Ch∆∞a t·∫£i)';
                                } else if (data.models[modelKey].loaded) {
                                    option.textContent = option.textContent.replace(' ‚≠ê', '') + ' ‚úÖ';
                                }
                            }
                        }
                    });
                }
            } catch (error) {
                console.log('Local models check failed:', error);
            }
        }
        
        // Dark Mode
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
            darkModeBtn.textContent = '‚òÄÔ∏è';
        }
        
        darkModeBtn.addEventListener('click', function() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            darkModeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        });
        
        // Configure marked.js
        marked.setOptions({
            breaks: true,
            gfm: true,
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                }
                return hljs.highlightAuto(code).value;
            }
        });
        
        const modelNames = {
            'gemini': 'Gemini',
            'openai': 'GPT-4o-mini',
            'deepseek': 'DeepSeek',
            'qwen': 'Qwen1.5b',
            'bloomvn': 'BloomVN-8B API',
            'bloomvn-local': 'BloomVN-8B Local',
            'qwen1.5-local': 'Qwen1.5 Local',
            'qwen2.5-local': 'Qwen2.5-14B Local'
        };
        
        const contextNames = {
            'casual': 'Tr√≤ chuy·ªán vui v·∫ª',
            'psychological': 'T√¢m l√Ω - T√¢m s·ª±',
            'lifestyle': 'Gi·∫£i ph√°p ƒë·ªùi s·ªëng',
            'programming': 'üíª H·ªó tr·ª£ l·∫≠p tr√¨nh'
        };
        
        function formatTimestamp(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        // Auto-resize textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });
        
        // Tool buttons
        googleSearchBtn.addEventListener('click', function() {
            toggleTool('google-search', this);
        });
        
        githubBtn.addEventListener('click', function() {
            toggleTool('github', this);
        });
        
        imageGenToolBtn.addEventListener('click', function() {
            toggleTool('image-generation', this);
        });

        // Img2Img tool button - open modal directly with Img2Img tab
        const img2imgToolBtn = document.getElementById('img2imgToolBtn');
        if (img2imgToolBtn) {
            img2imgToolBtn.addEventListener('click', async function() {
                console.log('[Img2Img Tool] Opening modal...');
                await openImageModal();
                // Switch to img2img tab after modal opens
                setTimeout(() => {
                    switchImageGenTab('img2img');
                }, 100);
            });
        }
        
        function toggleTool(tool, btn) {
            if (activeTools.has(tool)) {
                activeTools.delete(tool);
                btn.classList.remove('active');
            } else {
                activeTools.add(tool);
                btn.classList.add('active');
            }
        }
        
        // File upload - support multiple files
        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                // Add new files to the array
                for (let file of this.files) {
                    uploadedFiles.push(file);
                }
                renderFileList();
            }
        });
        
        // Render uploaded files
        function renderFileList() {
            fileList.innerHTML = '';
            uploadedFiles.forEach((file, index) => {
                const tag = document.createElement('div');
                tag.className = 'file-tag';
                tag.innerHTML = `
                    üìÑ ${file.name}
                    <span class="file-tag-remove" onclick="removeFile(${index})">‚úï</span>
                `;
                fileList.appendChild(tag);
            });
        }
        
        // Remove file from list
        function removeFile(index) {
            uploadedFiles.splice(index, 1);
            renderFileList();
        }
        
        // Handle paste event for text/files
        messageInput.addEventListener('paste', async function(e) {
            const items = e.clipboardData.items;
            
            for (let item of items) {
                // Handle text paste (default behavior)
                if (item.type === 'text/plain') {
                    // Let default paste happen
                    continue;
                }
                
                // Handle file paste
                if (item.kind === 'file') {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        uploadedFiles.push(file);
                        renderFileList();
                    }
                }
            }
        });
        
        function addMessage(content, isUser, model, context, timestamp) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
            messageDiv.dataset.timestamp = timestamp || formatTimestamp(new Date());
            messageDiv.dataset.model = model || '';
            messageDiv.dataset.context = context || '';
            
            // Assign unique message ID for user messages (for history tracking)
            if (isUser) {
                messageDiv.dataset.messageId = `msg_${Date.now()}_${Math.random()}`;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            if (isUser) {
                textDiv.textContent = content;
            } else {
                // Parse markdown for assistant messages
                textDiv.innerHTML = marked.parse(content);
                // Highlight code blocks
                textDiv.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
                
                // Add copy button for tables
                textDiv.querySelectorAll('table').forEach((table) => {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-table-btn';
                    copyBtn.textContent = 'üìã Copy b·∫£ng';
                    copyBtn.onclick = function() {
                        copyTableToClipboard(table, copyBtn);
                    };
                    table.parentNode.insertBefore(copyBtn, table.nextSibling);
                });
            }
            contentDiv.appendChild(textDiv);
            
            if (!isUser && model && context) {
                const infoDiv = document.createElement('div');
                infoDiv.className = 'message-info';
                infoDiv.textContent = `${modelNames[model]} ‚Ä¢ ${contextNames[context]}`;
                contentDiv.appendChild(infoDiv);
            }
            
            // Add timestamp
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = timestamp || formatTimestamp(new Date());
            contentDiv.appendChild(timestampDiv);
            
            // Add buttons
            if (!isUser) {
                // Copy button for assistant messages
                const copyMsgBtn = document.createElement('button');
                copyMsgBtn.className = 'copy-message-btn';
                copyMsgBtn.textContent = 'üìã Copy';
                copyMsgBtn.onclick = function() {
                    copyMessageToClipboard(content, copyMsgBtn);
                };
                contentDiv.appendChild(copyMsgBtn);
            } else {
                // Edit button for user messages
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-message-btn';
                editBtn.textContent = '‚úèÔ∏è Edit';
                editBtn.onclick = function() {
                    showEditForm(messageDiv, content);
                };
                contentDiv.appendChild(editBtn);
            }
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Save to history
            chatHistory.push({
                content: content,
                isUser: isUser,
                model: model,
                context: context,
                timestamp: timestamp || formatTimestamp(new Date())
            });
            
            // Save to current chat session
            if (currentChatId && chatSessions[currentChatId]) {
                chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                chatSessions[currentChatId].updatedAt = new Date();
                
                // Generate title for first user message using Gemini
                // Check if this is the first user message and title is still default
                if (isUser && chatSessions[currentChatId].title === 'Cu·ªôc tr√≤ chuy·ªán m·ªõi') {
                    generateTitle(content).then(title => {
                        if (currentChatId && chatSessions[currentChatId]) {
                            chatSessions[currentChatId].title = title || content.substring(0, 30);
                            saveSessions();
                            renderChatList();
                        }
                    }).catch(err => {
                        console.error('Failed to generate title:', err);
                        // Fallback to first few words of content
                        if (currentChatId && chatSessions[currentChatId]) {
                            chatSessions[currentChatId].title = content.substring(0, 30) + (content.length > 30 ? '...' : '');
                            saveSessions();
                            renderChatList();
                        }
                    });
                }
                
                saveSessions();
                renderChatList();
            }
            
            // Make images clickable after adding message
            setTimeout(() => {
                if (window.makeImagesClickable) {
                    window.makeImagesClickable();
                }
            }, 100);
        }
        
        function copyMessageToClipboard(content, button) {
            // Copy plain text content
            const plainText = content.replace(/<[^>]*>/g, '').trim();
            
            navigator.clipboard.writeText(plainText).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úÖ ƒê√£ copy!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Kh√¥ng th·ªÉ copy. Vui l√≤ng th·ª≠ l·∫°i!');
            });
        }
        
        // Show edit form for user message
        function showEditForm(messageDiv, originalContent) {
            // Check if edit form already exists
            if (messageDiv.querySelector('.edit-form')) {
                return;
            }
            
            // Save current content to history before editing (if not already saved)
            const messageId = messageDiv.dataset.messageId || `msg_${Date.now()}_${Math.random()}`;
            messageDiv.dataset.messageId = messageId;
            
            // Only save to history if this is the first edit
            if (!messageHistory.has(messageId)) {
                addMessageVersion(messageId, originalContent, new Date().toISOString());
            }
            
            // Create edit form
            const editForm = document.createElement('div');
            editForm.className = 'edit-form';
            
            const textarea = document.createElement('textarea');
            textarea.value = originalContent;
            textarea.placeholder = 'Ch·ªânh s·ª≠a tin nh·∫Øn...';
            
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'edit-form-buttons';
            
            const saveBtn = document.createElement('button');
            saveBtn.className = 'edit-save-btn';
            saveBtn.textContent = 'üíæ L∆∞u & T·∫°o l·∫°i response';
            saveBtn.onclick = function() {
                handleEditSave(messageDiv, textarea.value, originalContent);
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'edit-cancel-btn';
            cancelBtn.textContent = '‚ùå H·ªßy';
            cancelBtn.onclick = function() {
                editForm.remove();
            };
            
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(cancelBtn);
            editForm.appendChild(textarea);
            editForm.appendChild(buttonsDiv);
            
            messageDiv.querySelector('.message-content').appendChild(editForm);
            textarea.focus();
        }
        
        // Handle edit save and re-generate response
        async function handleEditSave(messageDiv, newContent, originalContent) {
            if (!newContent.trim()) {
                alert('Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!');
                return;
            }
            
            if (newContent === originalContent) {
                alert('N·ªôi dung kh√¥ng thay ƒë·ªïi!');
                return;
            }
            
            // Save the current content to history before updating
            const messageId = messageDiv.dataset.messageId;
            if (messageId) {
                const currentText = messageDiv.querySelector('.message-text')?.textContent || originalContent;
                addMessageVersion(messageId, currentText, new Date().toISOString());
            }
            
            // Get all messages before this one
            const allMessages = Array.from(chatContainer.children);
            const messageIndex = allMessages.indexOf(messageDiv);
            
            // Build conversation history up to this point
            const historyBeforeEdit = [];
            for (let i = 0; i < messageIndex; i++) {
                const msg = allMessages[i];
                const isUser = msg.classList.contains('user');
                const textContent = msg.querySelector('.message-text')?.textContent || '';
                
                historyBeforeEdit.push({
                    role: isUser ? 'user' : 'assistant',
                    content: textContent
                });
            }
            
            // Update the message text
            const textDiv = messageDiv.querySelector('.message-text');
            textDiv.textContent = newContent;
            
            // Remove edit form
            messageDiv.querySelector('.edit-form')?.remove();
            
            // Add or update history button
            let historyBtn = messageDiv.querySelector('.message-history-btn');
            if (!historyBtn && messageHistory.has(messageId)) {
                historyBtn = document.createElement('button');
                historyBtn.className = 'message-history-btn';
                historyBtn.textContent = 'üìú Xem l·ªãch s·ª≠';
                historyBtn.onclick = function() {
                    showMessageHistory(messageId);
                };
                
                // Insert after edit button
                const editBtn = messageDiv.querySelector('.edit-message-btn');
                if (editBtn) {
                    editBtn.parentNode.insertBefore(historyBtn, editBtn.nextSibling);
                } else {
                    messageDiv.querySelector('.message-content').appendChild(historyBtn);
                }
            }
            
            // Remove all messages after this one
            for (let i = allMessages.length - 1; i > messageIndex; i--) {
                allMessages[i].remove();
            }
            
            // Get model and context from message data or use current settings
            const model = messageDiv.dataset.model || modelSelect.value;
            const context = messageDiv.dataset.context || contextSelect.value;
            const deepThinking = deepThinkingCheck.checked;
            
            // Show loading
            loading.classList.add('active');
            sendBtn.disabled = true;
            
            try {
                // Call backend to regenerate response with edited input
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: newContent,
                        model: model,
                        context: context,
                        deep_thinking: deepThinking,
                        tools: [],
                        history: historyBeforeEdit
                    })
                });
                
                const data = await response.json();
                const responseTimestamp = formatTimestamp(new Date());
                
                if (data.error) {
                    addMessage(`‚ùå **L·ªói:** ${data.error}`, false, model, context, responseTimestamp);
                } else {
                    addMessage(data.response, false, model, context, responseTimestamp);
                }
                
                // Update chat history
                chatHistory = [];
                Array.from(chatContainer.children).forEach(msgEl => {
                    const isUser = msgEl.classList.contains('user');
                    const content = msgEl.querySelector('.message-text')?.textContent || '';
                    const msgModel = msgEl.dataset.model || '';
                    const msgContext = msgEl.dataset.context || '';
                    const msgTimestamp = msgEl.dataset.timestamp || '';
                    
                    chatHistory.push({
                        content: content,
                        isUser: isUser,
                        model: msgModel,
                        context: msgContext,
                        timestamp: msgTimestamp
                    });
                });
                
                // Save to session
                if (currentChatId && chatSessions[currentChatId]) {
                    chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                    chatSessions[currentChatId].updatedAt = new Date();
                    saveSessions();
                    renderChatList();
                }
                
            } catch (error) {
                addMessage(`‚ùå **L·ªói k·∫øt n·ªëi:** ${error.message}`, false, model, context, 
                          formatTimestamp(new Date()));
            } finally {
                loading.classList.remove('active');
                sendBtn.disabled = false;
            }
        }
        
        function copyTableToClipboard(table, button) {
            // Convert table to TSV (Tab-separated values) for Excel compatibility
            let tsv = '';
            const rows = table.querySelectorAll('tr');
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('th, td');
                const rowData = [];
                cells.forEach(cell => {
                    rowData.push(cell.textContent.trim());
                });
                tsv += rowData.join('\t') + '\n';
            });
            
            // Copy to clipboard
            navigator.clipboard.writeText(tsv).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úÖ ƒê√£ copy!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Kh√¥ng th·ªÉ copy b·∫£ng. Vui l√≤ng th·ª≠ l·∫°i.');
            });
        }
        
        async function downloadChat() {
            const messages = Array.from(chatContainer.children);
            if (messages.length === 0) {
                alert('Ch∆∞a c√≥ l·ªãch s·ª≠ chat ƒë·ªÉ t·∫£i xu·ªëng!');
                return;
            }
            
            // Show loading
            const loadingMsg = addMessage('üîÑ ƒêang t·∫°o PDF...', false, 'System', 'casual');
            
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const maxWidth = pageWidth - (margin * 2);
                let yOffset = margin;
                
                // Helper function to add text as image (for Unicode support)
                async function addTextAsImage(text, fontSize, isBold, xPos, yPos, maxW) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set font
                    ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px Arial, sans-serif`;
                    
                    // Measure text
                    const metrics = ctx.measureText(text);
                    const textWidth = metrics.width;
                    
                    // Set canvas size
                    canvas.width = Math.min(textWidth + 10, maxW * 3.78); // mm to px
                    canvas.height = fontSize * 1.5;
                    
                    // Redraw with proper size
                    ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px Arial, sans-serif`;
                    ctx.fillStyle = '#000000';
                    ctx.textBaseline = 'top';
                    
                    // Word wrap if needed
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = words[0];
                    
                    for (let i = 1; i < words.length; i++) {
                        const testLine = currentLine + ' ' + words[i];
                        const testWidth = ctx.measureText(testLine).width;
                        
                        if (testWidth > maxW * 3.78) {
                            lines.push(currentLine);
                            currentLine = words[i];
                        } else {
                            currentLine = testLine;
                        }
                    }
                    lines.push(currentLine);
                    
                    // Adjust canvas height for multiple lines
                    canvas.height = lines.length * fontSize * 1.5;
                    ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px Arial, sans-serif`;
                    ctx.fillStyle = '#000000';
                    ctx.textBaseline = 'top';
                    
                    // Draw text lines
                    lines.forEach((line, idx) => {
                        ctx.fillText(line, 5, idx * fontSize * 1.5);
                    });
                    
                    // Convert to image
                    const imgData = canvas.toDataURL('image/png');
                    const imgWidth = Math.min(maxW, canvas.width / 3.78);
                    const imgHeight = canvas.height / 3.78;
                    
                    return { imgData, imgWidth, imgHeight, lineCount: lines.length };
                }
                
                // Title
                const titleData = await addTextAsImage('AI CHATBOT - L·ªäCH S·ª¨ H·ªòI THO·∫†I', 24, true, 0, 0, maxWidth);
                pdf.addImage(titleData.imgData, 'PNG', (pageWidth - titleData.imgWidth) / 2, yOffset, titleData.imgWidth, titleData.imgHeight);
                yOffset += titleData.imgHeight + 5;
                
                // Timestamp
                const timestampText = 'Xu·∫•t l√∫c: ' + new Date().toLocaleString('vi-VN');
                const timestampData = await addTextAsImage(timestampText, 12, false, 0, 0, maxWidth);
                pdf.addImage(timestampData.imgData, 'PNG', (pageWidth - timestampData.imgWidth) / 2, yOffset, timestampData.imgWidth, timestampData.imgHeight);
                yOffset += timestampData.imgHeight + 10;
                
                // Process each message
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    const isUser = msg.classList.contains('user');
                    const textEl = msg.querySelector('.message-text');
                    const imageEl = msg.querySelector('img');
                    
                    // Check if need new page
                    if (yOffset > pageHeight - 40) {
                        pdf.addPage();
                        yOffset = margin;
                    }
                    
                    // Message header
                    const header = isUser ? 'üë§ USER' : 'ü§ñ AI';
                    const headerData = await addTextAsImage(header, 14, true, 0, 0, maxWidth);
                    pdf.addImage(headerData.imgData, 'PNG', margin, yOffset, headerData.imgWidth, headerData.imgHeight);
                    yOffset += headerData.imgHeight + 3;
                    
                    // Message text
                    if (textEl) {
                        const text = textEl.textContent || '';
                        
                        // Split into chunks for better pagination
                        const maxCharsPerChunk = 500;
                        const chunks = [];
                        for (let j = 0; j < text.length; j += maxCharsPerChunk) {
                            chunks.push(text.substring(j, j + maxCharsPerChunk));
                        }
                        
                        for (const chunk of chunks) {
                            const textData = await addTextAsImage(chunk, 12, false, 0, 0, maxWidth);
                            
                            // Check pagination
                            if (yOffset + textData.imgHeight > pageHeight - margin) {
                                pdf.addPage();
                                yOffset = margin;
                            }
                            
                            pdf.addImage(textData.imgData, 'PNG', margin, yOffset, textData.imgWidth, textData.imgHeight);
                            yOffset += textData.imgHeight + 2;
                        }
                    }
                    
                    // Check if this message has images (multiple possible)
                    const allImages = msg.querySelectorAll('img');
                    for (const imgEl of allImages) {
                        if (imgEl && imgEl.src) {
                            yOffset += 5;
                            
                            try {
                                // Convert image to canvas then to dataURL
                                const canvas = await html2canvas(imgEl, {
                                    scale: 1,
                                    logging: false,
                                    backgroundColor: null
                                });
                                
                                const imgData = canvas.toDataURL('image/jpeg', 0.7);
                                const imgWidth = Math.min(maxWidth, 100);
                                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                                
                                // Check if need new page for image
                                if (yOffset + imgHeight > pageHeight - margin) {
                                    pdf.addPage();
                                    yOffset = margin;
                                }
                                
                                pdf.addImage(imgData, 'JPEG', margin, yOffset, imgWidth, imgHeight);
                                yOffset += imgHeight + 5;
                                
                                // Look for metadata in parent message
                                const metadataDiv = imgEl.closest('.message')?.querySelector('div[style*="background: rgba(76, 175, 80"]');
                                if (metadataDiv) {
                                    const metadataText = metadataDiv.textContent || '';
                                    // Clean up metadata text
                                    const cleanMetadata = metadataText
                                        .replace(/\s+/g, ' ')
                                        .replace(/üìù|‚ùå|üñºÔ∏è|üé≤|üíæ/g, '')
                                        .trim();
                                    
                                    if (cleanMetadata) {
                                        const metadataData = await addTextAsImage('‚öôÔ∏è ' + cleanMetadata, 9, false, 0, 0, maxWidth);
                                        
                                        // Check pagination
                                        if (yOffset + metadataData.imgHeight > pageHeight - margin) {
                                            pdf.addPage();
                                            yOffset = margin;
                                        }
                                        
                                        pdf.addImage(metadataData.imgData, 'PNG', margin, yOffset, metadataData.imgWidth, metadataData.imgHeight);
                                        yOffset += metadataData.imgHeight + 5;
                                    }
                                }
                            } catch (imgError) {
                                console.warn('Cannot add image to PDF:', imgError);
                                const placeholderData = await addTextAsImage('[H√¨nh ·∫£nh]', 11, false, 0, 0, maxWidth);
                                pdf.addImage(placeholderData.imgData, 'PNG', margin, yOffset, placeholderData.imgWidth, placeholderData.imgHeight);
                                yOffset += placeholderData.imgHeight + 3;
                            }
                        }
                    }
                    
                    // Separator
                    yOffset += 5;
                    pdf.setDrawColor(200, 200, 200);
                    pdf.line(margin, yOffset, pageWidth - margin, yOffset);
                    yOffset += 10;
                }
                
                // Save PDF
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                pdf.save(`chat-history-${timestamp}.pdf`);
                
                // Remove loading message
                chatContainer.removeChild(loadingMsg);
                
            } catch (error) {
                console.error('Error creating PDF:', error);
                chatContainer.removeChild(loadingMsg);
                alert('‚ùå L·ªói khi t·∫°o PDF: ' + error.message);
            }
        }
        
        downloadBtn.addEventListener('click', downloadChat);
        
        // ============================================================================
        // MEMORY / AI LEARNING FUNCTIONS
        // ============================================================================
        
        // Toggle memory panel
        memoryBtn.addEventListener('click', function() {
            const isVisible = memoryPanel.style.display !== 'none';
            memoryPanel.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                loadMemories();
            }
        });
        
        // Load all memories
        async function loadMemories() {
            try {
                const response = await fetch('/api/memory/list');
                const data = await response.json();
                
                if (data.memories) {
                    allMemories = data.memories;
                    renderMemoryList();
                }
            } catch (error) {
                console.error('Error loading memories:', error);
                alert('L·ªói khi t·∫£i memories: ' + error.message);
            }
        }
        
        // Render memory list
        function renderMemoryList() {
            if (allMemories.length === 0) {
                memoryListEl.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">Ch∆∞a c√≥ b√†i h·ªçc n√†o ƒë∆∞·ª£c l∆∞u.</div>';
                return;
            }
            
            memoryListEl.innerHTML = allMemories.map(mem => {
                const isChecked = selectedMemories.has(mem.id);
                const preview = mem.content.substring(0, 100) + (mem.content.length > 100 ? '...' : '');
                
                return `
                    <div class="memory-item">
                        <input type="checkbox" 
                               id="mem-${mem.id}" 
                               ${isChecked ? 'checked' : ''}
                               onchange="toggleMemory('${mem.id}')">
                        <div class="memory-item-content">
                            <div class="memory-item-title">${mem.title}</div>
                            <div class="memory-item-preview">${preview}</div>
                        </div>
                        <div class="memory-item-actions">
                            <button class="memory-delete-btn" onclick="deleteMemory('${mem.id}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Toggle memory selection
        function toggleMemory(memoryId) {
            if (selectedMemories.has(memoryId)) {
                selectedMemories.delete(memoryId);
            } else {
                selectedMemories.add(memoryId);
            }
            console.log('Selected memories:', Array.from(selectedMemories));
        }
        
        // Save current chat as memory
        saveMemoryBtn.addEventListener('click', async function() {
            // Get all messages from chat
            const messages = Array.from(chatContainer.children);
            if (messages.length === 0) {
                alert('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ l∆∞u!');
                return;
            }
            
            // Build content and collect images
            let content = '';
            const images = [];
            
            messages.forEach(msg => {
                const isUser = msg.classList.contains('user');
                const textEl = msg.querySelector('.message-text');
                
                // Add text content
                if (textEl) {
                    const text = textEl.textContent || '';
                    content += `${isUser ? 'User' : 'AI'}: ${text}\n\n`;
                }
                
                // Collect images - search in all child elements
                const allImages = msg.querySelectorAll('img');
                allImages.forEach(imageEl => {
                    if (imageEl && imageEl.src) {
                        const imgSrc = imageEl.src;
                        console.log('Found image:', imgSrc);
                        
                        if (imgSrc.startsWith('http') && imgSrc.includes('/storage/images/')) {
                            // Server-stored image
                            const relativePath = imgSrc.substring(imgSrc.indexOf('/storage/images/'));
                            images.push({ url: relativePath });
                            console.log('Added server image:', relativePath);
                        } else if (imgSrc.startsWith('data:image')) {
                            // Base64 image
                            images.push({ base64: imgSrc });
                            console.log('Added base64 image');
                        }
                    }
                });
            });
            
            console.log('Total images collected:', images.length);
            console.log('Images array:', images);
            
            // Show loading
            const loadingMsg = addMessage('ü§ñ ƒêang t·∫°o ti√™u ƒë·ªÅ...', false, 'System', 'casual');
            
            try {
                // Ask AI to generate title
                const model = modelSelect.value;
                const titlePrompt = `Based on this conversation, generate a short, descriptive title (max 30 characters, in Vietnamese).

Conversation:
${content.substring(0, 500)}...

Return ONLY the title, nothing else.`;

                const titleResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: titlePrompt,
                        model: model,
                        context: 'casual',
                        deep_thinking: false,
                        tools: []
                    })
                });
                
                const titleData = await titleResponse.json();
                let title = titleData.response.trim();
                
                // Clean up title (remove quotes, limit length)
                title = title.replace(/["']/g, '').substring(0, 30);
                
                // Remove loading message safely
                if (loadingMsg && loadingMsg.parentNode === chatContainer) {
                    chatContainer.removeChild(loadingMsg);
                }
                
                // Show confirmation dialog with AI-generated title
                const confirmMsg = images.length > 0 
                    ? `Ti√™u ƒë·ªÅ AI t·∫°o: "${title}"\n\nB√†i h·ªçc c√≥ ${images.length} ·∫£nh.\n·∫¢nh s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o:\n./ChatBot/data/memory/${title}_[timestamp]/image_gen/\n\nTi·∫øp t·ª•c?`
                    : `Ti√™u ƒë·ªÅ AI t·∫°o: "${title}"\n\nL∆∞u b√†i h·ªçc n√†y?`;
                    
                if (!confirm(confirmMsg)) return;
                
                // Auto-generate tags from content (simple keyword extraction)
                const tags = [];
                const contentLower = content.toLowerCase();
                const commonKeywords = ['python', 'javascript', 'java', 'react', 'vue', 'angular', 'node', 'api', 'database', 'sql', 'docker', 'git', 'linux', 'windows', 'programming', 'code', 'bug', 'error', 'fix', 'anime', 'art', 'design', 'image', 'photo'];
                commonKeywords.forEach(keyword => {
                    if (contentLower.includes(keyword)) {
                        tags.push(keyword);
                    }
                });
                
                // Save to backend
                const saveResponse = await fetch('/api/memory/save', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        title: title,
                        content: content,
                        tags: tags.slice(0, 5), // Max 5 tags
                        images: images
                    })
                });
                
                const saveData = await saveResponse.json();
                
                if (saveData.success) {
                    const imgMsg = images.length > 0 ? ` (v·ªõi ${images.length} ·∫£nh)` : '';
                    alert('‚úÖ ƒê√£ l∆∞u b√†i h·ªçc th√†nh c√¥ng' + imgMsg + '!\n\nTi√™u ƒë·ªÅ: ' + title);
                    loadMemories(); // Reload list
                } else {
                    alert('‚ùå L·ªói: ' + (saveData.error || 'Unknown error'));
                }
                
            } catch (error) {
                console.error('Error saving memory:', error);
                // Remove loading message safely if it exists
                if (loadingMsg && loadingMsg.parentNode === chatContainer) {
                    chatContainer.removeChild(loadingMsg);
                }
                alert('‚ùå L·ªói khi l∆∞u: ' + error.message);
            }
        });
        
        // Delete memory
        async function deleteMemory(memoryId) {
            console.log('Attempting to delete memory:', memoryId);
            
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b√†i h·ªçc n√†y?')) return;
            
            try {
                console.log('Sending DELETE request to:', `/api/memory/delete/${memoryId}`);
                
                const response = await fetch(`/api/memory/delete/${memoryId}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                console.log('Delete response:', data);
                
                if (data.success) {
                    selectedMemories.delete(memoryId); // Remove from selected
                    loadMemories(); // Reload list
                    alert('‚úÖ ƒê√£ x√≥a b√†i h·ªçc th√†nh c√¥ng!');
                } else {
                    alert('‚ùå L·ªói: ' + (data.error || 'Unknown error'));
                    console.error('Delete failed:', data);
                }
            } catch (error) {
                console.error('Error deleting memory:', error);
                alert('‚ùå L·ªói khi x√≥a: ' + error.message);
            }
        }
        
        // Load memories on page load
        loadMemories();
        
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            const model = modelSelect.value;
            const context = contextSelect.value;
            const deepThinking = deepThinkingCheck.checked;
            const userTimestamp = formatTimestamp(new Date());
            
            // Check if image generation tool is active
            if (activeTools.has('image-generation')) {
                await handleImageGenerationTool(message, model, context, deepThinking, userTimestamp);
                return;
            }
            
            // Build message with tools and files
            let fullMessage = message;
            
            // Add deep thinking instruction
            if (deepThinking) {
                fullMessage += '\n\n[Deep Thinking Mode: Please think carefully and provide detailed analysis]';
            }
            
            if (activeTools.size > 0) {
                fullMessage += '\n\n[Tools: ' + Array.from(activeTools).join(', ') + ']';
            }
            
            // Add file information
            if (uploadedFiles.length > 0) {
                fullMessage += `\n\n[${uploadedFiles.length} file(s) attached: ${uploadedFiles.map(f => f.name).join(', ')}]`;
                
                // Read file contents (for text files)
                for (let file of uploadedFiles) {
                    if (file.type.includes('text') || file.name.endsWith('.txt') || 
                        file.name.endsWith('.py') || file.name.endsWith('.js') || 
                        file.name.endsWith('.html') || file.name.endsWith('.css') || 
                        file.name.endsWith('.json')) {
                        try {
                            const content = await readFileAsText(file);
                            fullMessage += `\n\n--- File: ${file.name} ---\n${content}\n--- End of ${file.name} ---\n`;
                        } catch (err) {
                            console.error('Error reading file:', err);
                        }
                    }
                }
            }
            
            // Add user message
            addMessage(message, true, null, null, userTimestamp);
            messageInput.value = '';
            messageInput.style.height = 'auto';
            
            // Show loading
            loading.classList.add('active');
            sendBtn.disabled = true;
            conversationActive = true;
            
            try {
                const startTime = new Date();
                
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: fullMessage,
                        model: model,
                        context: context,
                        deep_thinking: deepThinking,
                        tools: Array.from(activeTools),
                        memory_ids: Array.from(selectedMemories)  // Send selected memories
                    })
                });
                
                const data = await response.json();
                const responseTimestamp = formatTimestamp(new Date());
                
                if (data.error) {
                    addMessage(`‚ùå **L·ªói:** ${data.error}`, false, model, context, responseTimestamp);
                } else {
                    addMessage(data.response, false, model, context, responseTimestamp);
                }
                
                // If tools were used, keep conversation active
                if (activeTools.size > 0) {
                    addMessage('üí° *Tools ƒëang ho·∫°t ƒë·ªông. Ti·∫øp t·ª•c h·ªôi tho·∫°i ho·∫∑c b·∫•m Cancel ƒë·ªÉ d·ª´ng.*', 
                              false, model, context, formatTimestamp(new Date()));
                }
                
            } catch (error) {
                addMessage(`‚ùå **L·ªói k·∫øt n·ªëi:** ${error.message}`, false, model, context, 
                          formatTimestamp(new Date()));
            } finally {
                loading.classList.remove('active');
                sendBtn.disabled = false;
                messageInput.focus();
                
                // Clear files if not using tools
                if (activeTools.size === 0) {
                    uploadedFiles = [];
                    fileList.innerHTML = '';
                    fileInput.value = '';
                    conversationActive = false;
                }
            }
        }
        
        // Helper function to read file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });
        }
        
        async function clearHistory() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch s·ª≠ chat hi·ªán t·∫°i?')) return;
            
            try {
                await fetch('/clear', {
                    method: 'POST'
                });
                
                chatContainer.innerHTML = '';
                chatHistory = []; // Clear history array
                
                addMessage('Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa b·∫°n. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay? üòä', 
                          false, 'gemini', 'casual', formatTimestamp(new Date()));
                
                // Reset tools and conversation state
                activeTools.clear();
                googleSearchBtn.classList.remove('active');
                githubBtn.classList.remove('active');
                conversationActive = false;
                
                // Clear files
                uploadedFiles = [];
                fileList.innerHTML = '';
                fileInput.value = '';
                
                // Update current session
                // Title will be auto-generated by addMessage() when user sends first message
                if (currentChatId && chatSessions[currentChatId]) {
                    chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                    chatSessions[currentChatId].title = 'Cu·ªôc tr√≤ chuy·ªán m·ªõi';
                    chatSessions[currentChatId].updatedAt = new Date();
                    saveSessions();
                    renderChatList();
                }
                
            } catch (error) {
                alert('L·ªói khi x√≥a l·ªãch s·ª≠: ' + error.message);
            }
        }
        
        sendBtn.addEventListener('click', sendMessage);
        clearBtn.addEventListener('click', clearHistory);
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Welcome message removed - chat starts clean
    </script>
    
    <!-- Image Generation Modal -->
    <div id="imageGenModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üé® T·∫°o ·∫£nh b·∫±ng AI</h2>
                <button class="close-modal" onclick="closeImageModal()">&times;</button>
            </div>
            
            <div id="sdStatus" class="sd-status offline">
                ƒêang ki·ªÉm tra Stable Diffusion...
            </div>

            <!-- Tab Navigation -->
            <div class="image-gen-tabs">
                <button class="tab-btn active" onclick="switchImageGenTab('text2img')">
                    ‚úçÔ∏è T·∫°o ·∫£nh t·ª´ prompt
                </button>
                <button class="tab-btn" onclick="switchImageGenTab('img2img')">
                    üñºÔ∏è T·∫°o ·∫£nh theo h√¨nh ·∫£nh
                </button>
            </div>

            <!-- Shared Model Selection -->
            <div class="form-group">
                <label>Model Checkpoint:</label>
                <select id="modelCheckpoint">
                    <option value="">ƒêang t·∫£i...</option>
                </select>
            </div>

            <!-- Text2Img Tab Content -->
            <div id="text2imgTab" class="tab-content active">
            
            <div class="form-group">
                <label>Prompt (M√¥ t·∫£ ·∫£nh b·∫°n mu·ªën t·∫°o):</label>
                <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                    <button onclick="randomPrompt()" style="padding: 5px 15px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üé≤ Random</button>
                </div>
                <textarea id="imagePrompt" rows="4" placeholder="1girl, beautiful, detailed face, long hair, cherry blossoms, sunset, masterpiece, best quality"></textarea>
            </div>
            
            <div class="form-group">
                <label>Negative Prompt (Nh·ªØng g√¨ KH√îNG mu·ªën c√≥):</label>
                <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                    <button onclick="randomNegativePrompt()" style="padding: 5px 15px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üé≤ Random</button>
                </div>
                <textarea id="negativePrompt" rows="3" placeholder="bad quality, blurry, distorted, ugly, worst quality"></textarea>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Width:</label>
                    <select id="imageWidth">
                        <option value="512" selected>512 (Safe)</option>
                        <option value="768">768</option>
                        <option value="1024">1024</option>
                        <option value="1280">1280</option>
                        <option value="1440">1440 (HD)</option>
                        <option value="1920">1920 (FHD)</option>
                        <option value="2560">2560 (4K HD)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Height:</label>
                    <select id="imageHeight">
                        <option value="512" selected>512 (Safe)</option>
                        <option value="768">768</option>
                        <option value="1024">1024</option>
                        <option value="1280">1280</option>
                        <option value="1440">1440 (HD)</option>
                        <option value="1920">1920 (FHD)</option>
                        <option value="2560">2560 (4K HD)</option>
                    </select>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Steps <span id="stepsLabel">(20-50 khuy·∫øn ngh·ªã)</span>:</label>
                    <input type="number" id="imageSteps" value="20" min="1" max="150">
                </div>
                
                <div class="form-group">
                    <label>CFG Scale <span id="cfgLabel">(7-12 khuy·∫øn ngh·ªã)</span>:</label>
                    <input type="number" id="cfgScale" value="7" min="1" max="30" step="0.5">
                </div>
            </div>
            
            <div class="form-group">
                <label>Sampler:</label>
                <select id="samplerSelect">
                    <option value="DPM++ 2M Karras" selected>DPM++ 2M Karras</option>
                    <option value="Euler a">Euler a</option>
                    <option value="Euler">Euler</option>
                    <option value="DDIM">DDIM</option>
                    <option value="DPM++ SDE Karras">DPM++ SDE Karras</option>
                </select>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="restoreFaces">
                        Restore Faces (GFPGAN)
                    </label>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="enableHR">
                        Hires. Fix (Ch·∫•t l∆∞·ª£ng cao)
                    </label>
                </div>
            </div>
            
            <!-- Lora Selection Section -->
            <div class="form-group" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                <label style="font-weight: 600;">üé® Lora Models (T√πy ch·ªçn):</label>
                <div id="loraSelectionContainer" style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                    <button type="button" id="addLoraBtn" class="secondary-btn" onclick="addLoraSelection()">
                        ‚ûï Th√™m Lora
                    </button>
                </div>
            </div>
            
            <!-- VAE Selection -->
            <div class="form-group">
                <label>üîß VAE Model:</label>
                <select id="vaeSelect">
                    <option value="">Automatic (M·∫∑c ƒë·ªãnh)</option>
                </select>
            </div>
            
            <button class="generate-btn" id="generateImageBtn" onclick="generateImage()">
                üé® T·∫°o ·∫£nh
            </button>

            </div>
            <!-- End Text2Img Tab -->

            <!-- Img2Img Tab Content -->
            <div id="img2imgTab" class="tab-content" style="display: none;">
                
                <!-- Upload Image Section -->
                <div class="form-group">
                    <label>üì§ Upload h√¨nh ·∫£nh g·ªëc (B·∫Øt bu·ªôc):</label>
                    <div class="upload-area" id="uploadArea" onclick="document.getElementById('sourceImage').click()">
                        <div id="uploadPlaceholder">
                            <span style="font-size: 48px;">üì∑</span>
                            <p>Click ƒë·ªÉ ch·ªçn ·∫£nh ho·∫∑c k√©o th·∫£ v√†o ƒë√¢y</p>
                            <p style="font-size: 12px; color: #999;">H·ªó tr·ª£: JPG, PNG, WebP</p>
                        </div>
                        <img id="sourceImagePreview" style="display: none; max-width: 100%; max-height: 300px; border-radius: 8px;">
                    </div>
                    <input type="file" id="sourceImage" accept="image/*" style="display: none;" onchange="handleSourceImageUpload(event)">
                </div>

                <!-- Extract Features Section -->
                <div id="featureExtractionSection" style="display: none;">
                    <div class="form-group">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="font-weight: 600;">üîç Tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng:</label>
                            <label style="font-size: 13px;">
                                <input type="checkbox" id="deepThinkingMode">
                                üß† Deep Thinking Mode (Chi ti·∫øt h∆°n)
                            </label>
                        </div>
                        
                        <!-- Multi-Model Selection -->
                        <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 152, 0, 0.1); border-radius: 4px;">
                            <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 8px;">
                                üéØ Extraction Models (Ch·ªçn nhi·ªÅu model = ch√≠nh x√°c h∆°n nh∆∞ng ch·∫≠m h∆°n):
                            </label>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                <label style="font-size: 12px; cursor: pointer;">
                                    <input type="checkbox" id="modelDeepDanbooru" value="deepdanbooru" checked>
                                    DeepDanbooru (Anime) üé®
                                </label>
                                <label style="font-size: 12px; cursor: pointer;">
                                    <input type="checkbox" id="modelCLIP" value="clip">
                                    CLIP (General) üåê
                                </label>
                                <label style="font-size: 12px; cursor: pointer;">
                                    <input type="checkbox" id="modelWD14" value="wd14">
                                    WD14 Tagger (Anime+) ‚≠ê
                                </label>
                            </div>
                            <p style="font-size: 11px; color: #666; margin-top: 5px;">
                                üí° Tip: Ch·ªçn nhi·ªÅu model ƒë·ªÉ ensemble extraction (tags ƒë∆∞·ª£c nhi·ªÅu model ƒë·ªìng √Ω = confidence cao h∆°n)
                            </p>
                        </div>
                        
                        <button class="extract-btn" onclick="extractFeatures()" style="width: 100%; padding: 10px; margin-bottom: 10px; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            üî¨ Tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng
                        </button>
                        <div id="extractedTags" style="display: none;">
                            <div style="margin-bottom: 10px; padding: 8px; background: rgba(255, 152, 0, 0.1); border-radius: 4px; font-size: 13px;">
                                üí° <strong>Tip:</strong> Click v√†o checkbox ƒë·ªÉ lo·∫°i b·ªè to√†n b·ªô category, ho·∫∑c click t·ª´ng tag ƒë·ªÉ lo·∫°i b·ªè ri√™ng l·∫ª
                            </div>
                            <div id="tagsList" style="max-height: 350px; overflow-y: auto; padding: 10px; background: #2a2a2a; border-radius: 4px; margin-bottom: 10px;">
                                <!-- Tags will be populated here by category -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Prompt Section for Img2Img -->
                <div class="form-group">
                    <label>Prompt b·ªï sung (c√≥ th·ªÉ t√πy ch·ªânh % b√™n d∆∞·ªõi):</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                        <button onclick="randomImg2ImgPrompt()" style="padding: 5px 15px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üé≤ Random</button>
                    </div>
                    <textarea id="img2imgPrompt" rows="3" placeholder="Nh·∫≠p prompt b·ªï sung ƒë·ªÉ ƒëi·ªÅu ch·ªânh ·∫£nh..."></textarea>
                </div>

                <div class="form-group">
                    <label>Negative Prompt:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                        <button onclick="randomImg2ImgNegativePrompt()" style="padding: 5px 15px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üé≤ Random</button>
                    </div>
                    <textarea id="img2imgNegativePrompt" rows="2" placeholder="bad quality, blurry, distorted"></textarea>
                </div>

                <!-- Image Size for Img2Img -->
                <div class="form-row">
                    <div class="form-group">
                        <label>Width:</label>
                        <select id="img2imgWidth">
                            <option value="512">512</option>
                            <option value="768" selected>768</option>
                            <option value="1024">1024</option>
                            <option value="1280">1280</option>
                            <option value="1440">1440 (HD)</option>
                            <option value="1920">1920 (FHD)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Height:</label>
                        <select id="img2imgHeight">
                            <option value="512">512</option>
                            <option value="768" selected>768</option>
                            <option value="1024">1024</option>
                            <option value="1280">1280</option>
                            <option value="1440">1440 (HD)</option>
                            <option value="1920">1920 (FHD)</option>
                        </select>
                    </div>
                </div>

                <!-- Generation Settings for Img2Img -->
                <div class="form-row">
                    <div class="form-group">
                        <label>Denoising Strength:</label>
                        <input type="number" id="denoisingStrength" value="0.6" min="0" max="1" step="0.05">
                    </div>
                    
                    <div class="form-group">
                        <label>Feature Weight (%):</label>
                        <input type="number" id="featureWeight" value="80" min="0" max="100" step="5">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Steps:</label>
                        <input type="number" id="img2imgSteps" value="30" min="1" max="150">
                    </div>
                    
                    <div class="form-group">
                        <label>CFG Scale:</label>
                        <input type="number" id="img2imgCfgScale" value="7" min="1" max="30" step="0.5">
                    </div>
                </div>
                
                <!-- Lora Selection for Img2Img -->
                <div class="form-group" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                    <label style="font-weight: 600;">üé® Lora Models (T√πy ch·ªçn):</label>
                    <div id="img2imgLoraSelectionContainer" style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                        <button type="button" id="addImg2imgLoraBtn" class="secondary-btn" onclick="addImg2imgLoraSelection()">
                            ‚ûï Th√™m Lora
                        </button>
                    </div>
                </div>
                
                <!-- VAE Selection for Img2Img -->
                <div class="form-group">
                    <label>üîß VAE Model:</label>
                    <select id="img2imgVaeSelect">
                        <option value="">Automatic (M·∫∑c ƒë·ªãnh)</option>
                    </select>
                </div>

                <button class="generate-btn" id="generateImg2ImgBtn" onclick="generateImg2Img()" disabled>
                    üé® T·∫°o ·∫£nh t·ª´ h√¨nh ·∫£nh
                </button>

            </div>
            <!-- End Img2Img Tab -->
            
            <div id="generatedImageContainer" style="display: none;">
                <img id="generatedImage" class="generated-image" alt="Generated Image">
                <div class="image-actions">
                    <button class="copy-to-chat-btn" onclick="copyImageToChat()">
                        üí¨ G·ª≠i v√†o Chat
                    </button>
                    <button class="download-image-btn" onclick="downloadGeneratedImage()">
                        üì• T·∫£i xu·ªëng
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Image Generation Functions
        let currentGeneratedImage = null;
        let sdModels = [];
        
        async function openImageModal() {
            console.log('[Image Modal] Opening modal...');
            const modal = document.getElementById('imageGenModal');
            modal.classList.add('active');
            
            // Check SD status
            await checkSDStatus();
            
            // Load models
            await loadSDModels();
            
            // Load samplers
            await loadSamplers();
            
            // Load Loras and VAEs
            await loadLoras();
            await loadVaes();
            
            // Initialize tabs (make sure text2img is visible)
            const text2imgTab = document.getElementById('text2imgTab');
            const img2imgTab = document.getElementById('img2imgTab');
            console.log('[Image Modal] text2imgTab:', text2imgTab);
            console.log('[Image Modal] img2imgTab:', img2imgTab);
            
            if (text2imgTab) text2imgTab.style.display = 'block';
            if (img2imgTab) img2imgTab.style.display = 'none';
        }
        
        function closeImageModal() {
            const modal = document.getElementById('imageGenModal');
            modal.classList.remove('active');
        }

        // Tab Switching
        function switchImageGenTab(tabName) {
            const text2imgTab = document.getElementById('text2imgTab');
            const img2imgTab = document.getElementById('img2imgTab');
            
            // Hide all tabs
            text2imgTab.style.display = 'none';
            text2imgTab.classList.remove('active');
            img2imgTab.style.display = 'none';
            img2imgTab.classList.remove('active');
            
            // Remove active from all tab buttons
            document.querySelectorAll('.image-gen-tabs .tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            if (tabName === 'text2img') {
                text2imgTab.style.display = 'block';
                text2imgTab.classList.add('active');
                document.querySelectorAll('.image-gen-tabs .tab-btn')[0].classList.add('active');
            } else if (tabName === 'img2img') {
                img2imgTab.style.display = 'block';
                img2imgTab.classList.add('active');
                document.querySelectorAll('.image-gen-tabs .tab-btn')[1].classList.add('active');
            }
            
            console.log(`[Tab Switch] Switched to ${tabName}`);
        }

        // Img2Img Variables
        let sourceImageFile = null;
        let sourceImageBase64 = null;
        let extractedTags = [];
        let extractedCategories = {};
        let filteredTags = new Set();
        let filteredCategories = new Set(); // Filter entire categories

        // Handle Source Image Upload
        function handleSourceImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn file h√¨nh ·∫£nh!');
                return;
            }
            
            sourceImageFile = file;
            
            // Preview image
            const reader = new FileReader();
            reader.onload = function(e) {
                sourceImageBase64 = e.target.result;
                const preview = document.getElementById('sourceImagePreview');
                const placeholder = document.getElementById('uploadPlaceholder');
                
                preview.src = sourceImageBase64;
                preview.style.display = 'block';
                placeholder.style.display = 'none';
                
                // Auto-detect image size and set width/height
                const img = new Image();
                img.onload = function() {
                    console.log(`[Img2Img] Detected image size: ${this.width}x${this.height}`);
                    document.getElementById('img2imgWidth').value = this.width;
                    document.getElementById('img2imgHeight').value = this.height;
                };
                img.src = sourceImageBase64;
                
                // Show feature extraction section
                document.getElementById('featureExtractionSection').style.display = 'block';
                
                // Reset extracted tags
                extractedTags = [];
                filteredTags.clear();
                filteredCategories.clear();
                document.getElementById('extractedTags').style.display = 'none';
                
                // Disable generate button until features extracted
                document.getElementById('generateImg2ImgBtn').disabled = true;
            };
            reader.readAsDataURL(file);
        }

        // Drag and Drop for Upload Area
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) {
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        document.getElementById('sourceImage').files = files;
                        handleSourceImageUpload({ target: { files: [file] } });
                    }
                }
            });
        }

        // Extract Features using Single or Multi Models
        async function extractFeatures() {
            if (!sourceImageBase64) {
                alert('‚ö†Ô∏è Vui l√≤ng upload ·∫£nh tr∆∞·ªõc!');
                return;
            }
            
            const extractBtn = document.querySelector('.extract-btn');
            extractBtn.disabled = true;
            
            try {
                const deepThinking = document.getElementById('deepThinkingMode').checked;
                
                // Get selected models
                const selectedModels = [];
                if (document.getElementById('modelDeepDanbooru').checked) selectedModels.push('deepdanbooru');
                if (document.getElementById('modelCLIP').checked) selectedModels.push('clip');
                if (document.getElementById('modelWD14').checked) selectedModels.push('wd14');
                
                if (selectedModels.length === 0) {
                    alert('‚ö†Ô∏è Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 model!');
                    extractBtn.disabled = false;
                    return;
                }
                
                // Use multi-model endpoint if more than 1 model selected
                const useMultiModel = selectedModels.length > 1;
                const endpoint = useMultiModel ? '/api/extract-anime-features-multi' : '/api/extract-anime-features';
                
                extractBtn.textContent = useMultiModel 
                    ? `‚è≥ ƒêang tr√≠ch xu·∫•t (${selectedModels.length} models)...` 
                    : '‚è≥ ƒêang tr√≠ch xu·∫•t...';
                
                const requestBody = {
                    image: sourceImageBase64.split(',')[1],
                    deep_thinking: deepThinking
                };
                
                if (useMultiModel) {
                    requestBody.models = selectedModels;
                }
                
                console.log(`[Extract] Using ${useMultiModel ? 'multi-model' : 'single-model'} endpoint with:`, selectedModels);
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (data.tags && data.categories) {
                    extractedTags = data.tags;
                    extractedCategories = data.categories;
                    
                    // Show model stats if multi-model
                    if (data.models_used && data.model_results) {
                        console.log('[Extract] Multi-model stats:', data.model_results);
                        const statsText = Object.entries(data.model_results)
                            .map(([model, count]) => `${model}: ${count} tags`)
                            .join(' | ');
                        console.log('[Extract] Results:', statsText);
                    }
                    
                    displayExtractedTagsByCategory();
                    document.getElementById('extractedTags').style.display = 'block';
                    document.getElementById('generateImg2ImgBtn').disabled = false;
                    
                    extractBtn.textContent = '‚úÖ ƒê√£ tr√≠ch xu·∫•t!';
                    setTimeout(() => {
                        extractBtn.textContent = 'üî¨ Tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng';
                    }, 2000);
                } else {
                    alert('‚ùå L·ªói: ' + (data.error || 'Kh√¥ng th·ªÉ tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng'));
                }
            } catch (error) {
                console.error('Extract error:', error);
                alert('‚ùå L·ªói khi tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng: ' + error.message);
            } finally {
                extractBtn.disabled = false;
            }
        }

        // Display Extracted Tags by Category
        function displayExtractedTagsByCategory() {
            const tagsList = document.getElementById('tagsList');
            
            const CATEGORY_NAMES = {
                'hair': 'üíá T√≥c',
                'eyes': 'üëÅÔ∏è M·∫Øt',
                'mouth': 'üëÑ Mi·ªáng',
                'face': 'üòä Khu√¥n m·∫∑t',
                'accessories': 'üëë Ph·ª• ki·ªán',
                'clothing': 'üëî Qu·∫ßn √°o',
                'body': 'üßç C∆° th·ªÉ',
                'pose': 'ü§∏ T∆∞ th·∫ø',
                'background': 'üèûÔ∏è Background',
                'style': 'üé® Style',
                'other': 'üì¶ Kh√°c'
            };
            
            let html = '';
            
            for (const [category, categoryTags] of Object.entries(extractedCategories)) {
                if (categoryTags.length === 0) continue;
                
                const categoryFiltered = filteredCategories.has(category);
                const categoryName = CATEGORY_NAMES[category] || category;
                
                html += `
                    <div class="tag-category">
                        <div class="tag-category-header">
                            <label style="cursor: pointer; user-select: none;">
                                <input type="checkbox" 
                                       ${categoryFiltered ? 'checked' : ''} 
                                       onchange="toggleCategory('${category}')"
                                       style="margin-right: 8px;">
                                <strong>${categoryName}</strong> 
                                <span style="opacity: 0.7;">(${categoryTags.length})</span>
                            </label>
                        </div>
                        <div class="tag-category-items ${categoryFiltered ? 'category-filtered' : ''}">
                `;
                
                for (const tag of categoryTags) {
                    const isFiltered = filteredTags.has(tag.name) || categoryFiltered;
                    
                    // Show votes/sources if multi-model extraction
                    let tagTitle = `Confidence: ${(tag.confidence * 100).toFixed(0)}%`;
                    if (tag.votes && tag.sources) {
                        tagTitle += `\nVotes: ${tag.votes} models\nSources: ${tag.sources.join(', ')}`;
                    }
                    
                    html += `
                        <span class="tag-item ${isFiltered ? 'filtered' : ''}" 
                              onclick="toggleTag('${tag.name}')"
                              title="${tagTitle}">
                            ${tag.name}
                            <span class="tag-confidence">
                                ${(tag.confidence * 100).toFixed(0)}%
                                ${tag.votes && tag.votes > 1 ? ` (${tag.votes}üéØ)` : ''}
                            </span>
                        </span>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            tagsList.innerHTML = html;
        }
        
        // Toggle entire category
        function toggleCategory(category) {
            if (filteredCategories.has(category)) {
                filteredCategories.delete(category);
                // Remove all tags in this category from filtered tags
                if (extractedCategories[category]) {
                    extractedCategories[category].forEach(tag => {
                        filteredTags.delete(tag.name);
                    });
                }
            } else {
                filteredCategories.add(category);
                // Add all tags in this category to filtered tags
                if (extractedCategories[category]) {
                    extractedCategories[category].forEach(tag => {
                        filteredTags.add(tag.name);
                    });
                }
            }
            displayExtractedTagsByCategory();
        }

        // Toggle Tag Filtering
        function toggleTag(tagName) {
            if (filteredTags.has(tagName)) {
                filteredTags.delete(tagName);
            } else {
                filteredTags.add(tagName);
            }
            displayExtractedTags();
        }

        // Generate Img2Img
        async function generateImg2Img() {
            if (!sourceImageBase64 || extractedTags.length === 0) {
                alert('‚ö†Ô∏è Vui l√≤ng upload ·∫£nh v√† tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng tr∆∞·ªõc!');
                return;
            }
            
            const generateBtn = document.getElementById('generateImg2ImgBtn');
            generateBtn.disabled = true;
            generateBtn.textContent = '‚è≥ ƒêang t·∫°o ·∫£nh...';
            
            try {
                // Get active tags (not filtered)
                const activeTags = extractedTags
                    .filter(tag => !filteredTags.has(tag.name))
                    .map(tag => tag.name);
                
                const userPrompt = document.getElementById('img2imgPrompt').value.trim();
                const featureWeight = parseInt(document.getElementById('featureWeight').value) / 100;
                
                const response = await fetch('/api/img2img-advanced', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_image: sourceImageBase64.split(',')[1],
                        extracted_tags: activeTags,
                        user_prompt: userPrompt,
                        feature_weight: featureWeight,
                        negative_prompt: document.getElementById('img2imgNegativePrompt').value,
                        denoising_strength: parseFloat(document.getElementById('denoisingStrength').value),
                        steps: parseInt(document.getElementById('img2imgSteps').value),
                        cfg_scale: parseFloat(document.getElementById('img2imgCfgScale').value),
                        width: parseInt(document.getElementById('img2imgWidth').value),
                        height: parseInt(document.getElementById('img2imgHeight').value),
                        model: document.getElementById('modelCheckpoint').value,
                        lora_models: getImg2imgSelectedLoras(),
                        vae: document.getElementById('img2imgVaeSelect').value || null
                    })
                });
                
                const data = await response.json();
                
                if (data.image) {
                    currentGeneratedImage = data;
                    
                    // Display in modal
                    document.getElementById('generatedImage').src = 'data:image/png;base64,' + data.image;
                    document.getElementById('generatedImageContainer').style.display = 'block';
                    
                    // Auto-send to chat with full metadata
                    const timestamp = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
                    const width = parseInt(document.getElementById('img2imgWidth').value);
                    const height = parseInt(document.getElementById('img2imgHeight').value);
                    const denoisingStrength = parseFloat(document.getElementById('denoisingStrength').value);
                    const steps = parseInt(document.getElementById('img2imgSteps').value);
                    const cfgScale = parseFloat(document.getElementById('img2imgCfgScale').value);
                    
                    const detailsId = 'details-' + Date.now();
                    const imageHtml = `
                        <div class="message assistant-message" style="max-width: 600px;">
                            <div class="message-header">
                                <strong>üñºÔ∏è Img2Img Result</strong>
                                <span class="timestamp">${timestamp}</span>
                            </div>
                            <div class="message-content">
                                <img src="data:image/png;base64,${data.image}" alt="Img2Img Generated" style="max-width: 100%; border-radius: 8px; margin: 10px 0; cursor: pointer;" loading="lazy" onclick="this.style.maxWidth = this.style.maxWidth === '100%' ? '300px' : '100%'">
                                <div style="margin-top: 10px;">
                                    <button onclick="document.getElementById('${detailsId}').style.display = document.getElementById('${detailsId}').style.display === 'none' ? 'block' : 'none'" 
                                            style="padding: 4px 10px; background: #673ab7; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; margin-bottom: 8px;">
                                        üìä Toggle Details
                                    </button>
                                    <div id="${detailsId}" style="display: none; padding: 10px; background: rgba(103, 58, 183, 0.1); border-left: 3px solid #673ab7; border-radius: 4px; font-size: 11px;">
                                        <strong>üìù Final Prompt:</strong><br>
                                        <code style="font-size: 10px; display: block; margin: 5px 0; white-space: pre-wrap; background: rgba(0,0,0,0.05); padding: 5px; border-radius: 3px;">${data.final_prompt || 'N/A'}</code>
                                        <div style="margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                                            <div><strong>üéØ User:</strong> ${userPrompt || '(none)'}</div>
                                            <div><strong>‚öñÔ∏è Weight:</strong> ${(featureWeight * 100).toFixed(0)}%/${((1 - featureWeight) * 100).toFixed(0)}%</div>
                                            <div><strong>üè∑Ô∏è Tags:</strong> ${activeTags.length}/${extractedTags.length}</div>
                                            <div><strong>üö´ Filtered:</strong> ${filteredTags.size} tags</div>
                                            <div><strong>üñºÔ∏è Size:</strong> ${width}√ó${height}</div>
                                            <div><strong>üé® Denoising:</strong> ${denoisingStrength}</div>
                                            <div><strong>üìè Steps:</strong> ${steps}</div>
                                            <div><strong>‚öôÔ∏è CFG:</strong> ${cfgScale}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Add to chat
                    const chatMessages = document.getElementById('chatContainer');
                    if (chatMessages) {
                        chatMessages.insertAdjacentHTML('beforeend', imageHtml);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // Make new images clickable
                        window.makeImagesClickable();
                        
                        // Save to current chat session
                        if (currentChatId && chatSessions[currentChatId]) {
                            chatSessions[currentChatId].messages = Array.from(chatMessages.children).map(el => el.outerHTML);
                            chatSessions[currentChatId].updatedAt = new Date();
                            saveSessions();
                        }
                    }
                    
                    generateBtn.textContent = '‚úÖ ƒê√£ t·∫°o & g·ª≠i v√†o chat!';
                    setTimeout(() => {
                        generateBtn.textContent = 'üé® T·∫°o ·∫£nh t·ª´ h√¨nh ·∫£nh';
                    }, 2000);
                } else {
                    alert('‚ùå L·ªói: ' + (data.error || 'Kh√¥ng th·ªÉ t·∫°o ·∫£nh'));
                }
            } catch (error) {
                console.error('Generation error:', error);
                alert('‚ùå L·ªói khi t·∫°o ·∫£nh: ' + error.message);
            } finally {
                generateBtn.disabled = false;
            }
        }
        
        async function checkSDStatus() {
            const statusDiv = document.getElementById('sdStatus');
            
            try {
                const response = await fetch('/api/sd-health');
                const data = await response.json();
                
                if (data.status === 'online') {
                    statusDiv.className = 'sd-status online';
                    statusDiv.textContent = `‚úÖ Stable Diffusion ƒëang ch·∫°y | Model: ${data.current_model.model}`;
                } else {
                    statusDiv.className = 'sd-status offline';
                    statusDiv.textContent = `‚ùå ${data.message}. Vui l√≤ng kh·ªüi ƒë·ªông Stable Diffusion WebUI v·ªõi flag --api`;
                }
            } catch (error) {
                statusDiv.className = 'sd-status offline';
                statusDiv.textContent = `‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi Stable Diffusion API`;
            }
        }
        
        async function loadSDModels() {
            const select = document.getElementById('modelCheckpoint');
            
            try {
                const response = await fetch('/api/sd-models');
                const data = await response.json();
                
                sdModels = data.models;
                select.innerHTML = '';
                
                data.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.title;
                    option.textContent = model.model_name;
                    if (model.title === data.current_model) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                
                // Add change event
                select.addEventListener('change', async (e) => {
                    const selectedModel = e.target.value;
                    if (selectedModel) {
                        await changeSDModel(selectedModel);
                    }
                });
                
            } catch (error) {
                select.innerHTML = '<option>L·ªói khi t·∫£i models</option>';
            }
        }
        
        async function changeSDModel(modelName) {
            try {
                // Show loading state
                const statusDiv = document.querySelector('.sd-status');
                if (statusDiv) {
                    statusDiv.innerHTML = '‚è≥ ƒêang thay ƒë·ªïi model...';
                    statusDiv.style.color = '#ff9800';
                }
                
                const response = await fetch('/api/sd-change-model', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({model_name: modelName})
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Update status immediately without refresh
                    await checkSDStatus();
                    
                    // Show success message briefly
                    if (statusDiv) {
                        statusDiv.innerHTML = `‚úÖ Model: ${modelName}`;
                        statusDiv.style.color = '#4caf50';
                    }
                }
            } catch (error) {
                console.error('Error changing model:', error);
                const statusDiv = document.querySelector('.sd-status');
                if (statusDiv) {
                    statusDiv.innerHTML = '‚ùå L·ªói thay ƒë·ªïi model';
                    statusDiv.style.color = '#f44336';
                }
            }
        }
        
        function randomPrompt() {
            const prompts = [
                "1girl, beautiful, detailed face, long hair, cherry blossoms, sunset, masterpiece, best quality",
                "anime girl, cyberpunk city, neon lights, rain, futuristic, highly detailed, 4k, best quality",
                "beautiful landscape, mountains, lake, sunrise, dramatic clouds, photorealistic, 8k",
                "fantasy castle, dragons flying, magical atmosphere, epic scene, detailed architecture",
                "cute cat, fluffy, big eyes, sitting on windowsill, sunlight, cozy room, adorable",
                "warrior, armor, sword, battle scene, dramatic lighting, heroic pose, fantasy art",
                "portrait, elegant woman, victorian dress, garden, flowers, soft lighting, painting style",
                "sci-fi spaceship, space station, stars, nebula, futuristic design, detailed interior",
                "underwater scene, coral reef, tropical fish, clear water, sunbeams, vibrant colors",
                "steampunk, mechanical, gears, brass, victorian era, industrial, detailed machinery"
            ];
            
            const randomIndex = Math.floor(Math.random() * prompts.length);
            document.getElementById('imagePrompt').value = prompts[randomIndex];
        }
        
        function randomNegativePrompt() {
            const negativePrompts = [
                "bad quality, blurry, distorted, ugly, worst quality",
                "low quality, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits",
                "worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated",
                "cropped, out of frame, blurry, bad art, deformed, poorly drawn, extra limbs, close up",
                "grainy, jpeg artifacts, watermark, signature, username, artist name, logo, text",
                "duplicate, morbid, mutilated, extra fingers, mutated hands, poorly drawn hands, poorly drawn face",
                "ugly, tiling, poorly drawn hands, poorly drawn feet, poorly drawn face, out of frame, mutation",
                "disfigured, deformed, cross-eye, body out of frame, bad anatomy, watermark, grainy, signature"
            ];
            
            const randomIndex = Math.floor(Math.random() * negativePrompts.length);
            document.getElementById('negativePrompt').value = negativePrompts[randomIndex];
        }

        // Random prompts for Img2Img (context-aware based on extracted tags)
        function randomImg2ImgPrompt() {
            // If tags are extracted, use smart variations
            if (extractedCategories && Object.keys(extractedCategories).length > 0) {
                const variations = [];
                
                // Hair variations
                if (extractedCategories['hair']?.length > 0) {
                    variations.push(
                        "different hair color, vibrant hair, gradient hair",
                        "longer hair, flowing hair, windblown hair",
                        "short hair, bob cut, modern hairstyle"
                    );
                }
                
                // Eyes variations
                if (extractedCategories['eyes']?.length > 0) {
                    variations.push(
                        "glowing eyes, sparkling eyes, heterochromia",
                        "detailed eyes, expressive eyes, beautiful eyes"
                    );
                }
                
                // Style variations
                variations.push(
                    "cyberpunk style, neon colors, futuristic tech",
                    "fantasy style, magical aura, glowing effects, sparkles",
                    "realistic style, photorealistic, detailed textures",
                    "chibi style, cute, adorable, kawaii, sd character",
                    "manga style, black and white, screentones, ink",
                    "watercolor style, soft colors, artistic, painterly",
                    "dark gothic style, dramatic shadows, mysterious",
                    "pastel colors, soft lighting, dreamy atmosphere"
                );
                
                // Expression variations
                variations.push(
                    "happy smile, joyful expression, bright eyes",
                    "serious expression, determined look, intense gaze",
                    "shy expression, blushing, looking away",
                    "confident pose, powerful stance, cool attitude"
                );
                
                const randomIndex = Math.floor(Math.random() * variations.length);
                document.getElementById('img2imgPrompt').value = variations[randomIndex];
            } else {
                // Fallback to basic prompts if no tags
                const prompts = [
                    "pink hair, red eyes, cute smile, detailed face",
                    "blue eyes, blonde hair, elegant pose, beautiful",
                    "cyberpunk style, neon colors, futuristic, high tech",
                    "fantasy style, magical aura, glowing effects, epic",
                    "realistic style, detailed textures, soft lighting, photorealistic",
                    "chibi style, cute, adorable, kawaii, sd character",
                    "different expression, happy, excited, energetic",
                    "anime style, vibrant colors, dynamic pose, masterpiece"
                ];
                
                const randomIndex = Math.floor(Math.random() * prompts.length);
                document.getElementById('img2imgPrompt').value = prompts[randomIndex];
            }
        }

        function randomImg2ImgNegativePrompt() {
            const negativePrompts = [
                "bad quality, blurry, distorted, worst quality, low quality, r18, nsfw",
                "low quality, bad anatomy, deformed, mutation, extra limbs, missing fingers",
                "worst quality, jpeg artifacts, watermark, signature, text, username",
                "ugly, poorly drawn, bad proportions, duplicate, malformed",
                "out of frame, cropped, bad composition, cut off, clipped",
                "grainy, low resolution, oversaturated colors, noise, pixelated",
                "disfigured, malformed, poorly drawn face, bad hands, fused fingers",
                "text, logo, copyright, lowres, bad anatomy, bad hands",
                "blurry, grainy, poorly drawn, amateur, low effort, rushed",
                "artifacts, compression, distorted features, asymmetric, unbalanced"
            ];
            
            const randomIndex = Math.floor(Math.random() * negativePrompts.length);
            document.getElementById('img2imgNegativePrompt').value = negativePrompts[randomIndex];
        }
        
        // Handle image generation tool
        async function handleImageGenerationTool(userMessage, model, context, deepThinking, userTimestamp) {
            // Add user message to chat
            addMessage(userMessage, true, null, null, userTimestamp);
            messageInput.value = '';
            messageInput.style.height = 'auto';
            
            // Show loading
            loading.classList.add('active');
            sendBtn.disabled = true;
            
            try {
                // Get selected memories for context
                let memoryContext = '';
                if (selectedMemories.size > 0) {
                    const memoryIds = Array.from(selectedMemories);
                    const memories = allMemories.filter(m => memoryIds.includes(m.id));
                    
                    if (memories.length > 0) {
                        memoryContext = '\n\n**Ki·∫øn th·ª©c c√≥ s·∫µn (b√†i h·ªçc ƒë√£ l∆∞u):**\n';
                        memories.forEach(mem => {
                            memoryContext += `- ${mem.title}: ${mem.content.substring(0, 200)}...\n`;
                        });
                    }
                }
                
                // Step 1: Get AI to generate improved prompt
                addMessage('ü§î ƒêang ph√¢n t√≠ch v√† t·∫°o prompt cho ·∫£nh...', false, model, context, formatTimestamp(new Date()));
                
                let promptInstruction = `Based on this user request: "${userMessage}"${memoryContext}

Generate an optimized Stable Diffusion prompt following these rules:
1. Write in English, comma-separated tags
2. Include quality tags: masterpiece, best quality, highly detailed
3. Be descriptive about: subject, style, lighting, composition, colors
4. Keep it concise but detailed (max 100 words)
5. Focus on visual elements only
${memoryContext ? '6. Use knowledge from the lessons above to create more accurate and detailed prompt' : ''}

${deepThinking ? 'Use deep thinking to create the most creative and detailed prompt possible.' : ''}

Return ONLY the prompt, nothing else.`;

                const promptResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: promptInstruction,
                        model: model,
                        context: context,
                        deep_thinking: deepThinking,
                        tools: [],
                        memory_ids: Array.from(selectedMemories)
                    })
                });
                
                const promptData = await promptResponse.json();
                const generatedPrompt = promptData.response.trim();
                
                // Show generated prompt
                addMessage(`‚ú® **Prompt ƒë∆∞·ª£c t·∫°o:**\n\`\`\`\n${generatedPrompt}\n\`\`\``, false, model, context, formatTimestamp(new Date()));
                
                // Step 2: Generate negative prompt with AI
                addMessage('üö´ ƒêang t·∫°o negative prompt...', false, model, context, formatTimestamp(new Date()));
                
                const negativeInstruction = `Based on this positive prompt, generate a detailed negative prompt to avoid common issues in AI image generation:

Positive prompt: "${generatedPrompt}"

Create a negative prompt that includes:
1. Common quality issues (bad quality, blurry, distorted, ugly, worst quality)
2. Anatomy issues (bad anatomy, bad hands, missing fingers, extra digit, fewer digits)
3. Unwanted content (r18, nsfw, nude, explicit, sexual, porn)
4. Technical issues (lowres, jpeg artifacts, cropped, out of frame)
5. Other common problems relevant to this image

Return ONLY the negative prompt (comma-separated keywords), nothing else.`;

                const negativeResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: negativeInstruction,
                        model: model,
                        context: context,
                        deep_thinking: false,
                        tools: []
                    })
                });
                
                const negativeData = await negativeResponse.json();
                let negativePrompt = negativeData.response.trim();
                
                // Add negative embeddings (MUST-HAVE for quality)
                const negativeEmbeddings = 'EasyNegative, BadDream, UnrealisticDream, bad-hands-5, verybadimagenegative';
                negativePrompt = `${negativeEmbeddings}, ${negativePrompt}`;
                
                // Show generated negative prompt
                addMessage(`üö´ **Negative prompt ƒë∆∞·ª£c t·∫°o:**\n\`\`\`\n${negativePrompt}\n\`\`\``, false, model, context, formatTimestamp(new Date()));
                
                // Step 3: Change to AnythingXL model (SDXL)
                addMessage('‚öôÔ∏è ƒêang chu·∫©n b·ªã model AnythingXL (SDXL)...', false, model, context, formatTimestamp(new Date()));
                
                try {
                    await fetch('/api/sd-change-model', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({model_name: 'AnythingXL_xl.safetensors'})
                    });
                } catch (e) {
                    console.log('Model already set or failed to change:', e);
                }
                
                // Step 4: Generate image with specified parameters
                addMessage('üé® ƒêang t·∫°o ·∫£nh SDXL 1024x1024... (c√≥ th·ªÉ m·∫•t 30-60 gi√¢y)', false, model, context, formatTimestamp(new Date()));
                
                const imageParams = {
                prompt: generatedPrompt,
                negative_prompt: negativePrompt + ", BadDream, UnrealisticDream, easynegative, bad quality, worst quality, low quality, jpeg artifacts, blurry, bad anatomy, bad hands",
                
                // SDXL optimal resolution (1024x1024 is native for SDXL)
                width: 1024,
                height: 1024,
                
                // SDXL settings (optimized for quality)
                steps: 30,  // SDXL works best with 25-40 steps
                cfg_scale: 7,  // SDXL optimal CFG is 6-8
                sampler_name: 'DPM++ 2M Karras',
                seed: -1,
                
                restore_faces: false,  // SDXL already produces good faces
                enable_hr: false,  // Not needed for SDXL at native resolution
                
                // SDXL-compatible Loras (only XL versions work with SDXL)
                lora_models: [
                    { name: 'add-detail-xl', weight: 0.7 },  // XL - Overall detail enhancement
                    { name: 'ponyxl_11eyes', weight: 0.6 },  // XL - Beautiful eyes
                    { name: 'Lora_Corrector_eyes_PonyXL', weight: 0.5 },  // XL - Eye correction
                    { name: 'akanbe-XL-V1', weight: 0.4 }  // XL - Art style enhancement
                ],
                
                // Best VAE for anime with SDXL
                vae: 'kl-f8-anime2.vae.safetensors',
                
                // Save images to SD WebUI gallery
                save_images: true,
                
                // Save to ChatBot storage (IMPORTANT for display in chat)
                save_to_storage: true
            };
                
                console.log('Generating image with params:', imageParams);
                
                const imageResponse = await fetch('/api/generate-image', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(imageParams)
                });
                
                const imageData = await imageResponse.json();
                console.log('Image response:', imageData);
                
                if (imageData.success && imageData.images && imageData.images.length > 0) {
                    // Check if image is already saved to storage (filename) or need to display base64
                    const firstImage = imageData.images[0];
                    let imageUrl;
                    let filename = '';
                    
                    if (firstImage.startsWith('generated_')) {
                        // Already saved to storage - construct URL from filename
                        imageUrl = `/storage/images/${firstImage}`;
                        filename = firstImage;
                        console.log('Image already saved:', filename);
                    } else {
                        // Base64 image - save to server first
                        try {
                            const saveResponse = await fetch('/api/save-image', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({
                                    image: firstImage,
                                    metadata: {
                                        prompt: generatedPrompt,
                                        negative_prompt: imageParams.negative_prompt,
                                        width: imageParams.width,
                                        height: imageParams.height,
                                        steps: imageParams.steps,
                                        cfg_scale: imageParams.cfg_scale,
                                        sampler_name: imageParams.sampler_name,
                                        model: 'AnythingXL_xl',
                                        lora_models: imageParams.lora_models,
                                        vae: imageParams.vae,
                                        source: 'text2image_tool'
                                    }
                                })
                            });
                            
                            const saveData = await saveResponse.json();
                            console.log('Image saved:', saveData);
                            
                            // Use server URL for display
                            imageUrl = saveData.success ? saveData.url : `data:image/png;base64,${firstImage}`;
                            filename = saveData.filename || '';
                        } catch (saveError) {
                            console.error('Error saving image:', saveError);
                            imageUrl = `data:image/png;base64,${firstImage}`;
                        }
                    }
                    
                    // Display image in chat
                    const timestamp = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
                    const imageHtml = `
                        <div class="message assistant-message">
                            <div class="message-header">
                                <strong>üé® ·∫¢nh ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!</strong>
                                <span class="timestamp">${timestamp}</span>
                            </div>
                            <div class="message-content">
                                <img src="${imageUrl}" alt="Generated Image" style="max-width: 100%; border-radius: 8px; margin: 10px 0;" loading="lazy">
                                <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50; border-radius: 4px;">
                                    <strong>üìù Prompt:</strong> ${generatedPrompt.substring(0, 150)}...<br>
                                    <strong>‚ùå Negative:</strong> ${imageParams.negative_prompt.substring(0, 100)}...<br>
                                    <strong>üñºÔ∏è Size:</strong> ${imageParams.width}x${imageParams.height} | <strong>Steps:</strong> ${imageParams.steps} | <strong>CFG:</strong> ${imageParams.cfg_scale}<br>
                                    <strong>üé≤ Sampler:</strong> ${imageParams.sampler_name} | <strong>ü§ñ Model:</strong> AnythingXL (SDXL)<br>
                                    <strong>üé® Lora:</strong> ${imageParams.lora_models.map(l => `${l.name}(${l.weight})`).join(', ')}<br>
                                    <strong>üé≠ VAE:</strong> ${imageParams.vae}
                                    ${filename ? `<br><strong>üíæ Saved:</strong> ${filename}` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    const chatMessages = document.getElementById('chatContainer');
                    if (chatMessages) {
                        chatMessages.insertAdjacentHTML('beforeend', imageHtml);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // Save to current chat session immediately
                        if (currentChatId && chatSessions[currentChatId]) {
                            chatSessions[currentChatId].messages = Array.from(chatMessages.children).map(el => el.outerHTML);
                            chatSessions[currentChatId].updatedAt = new Date();
                            saveSessions();
                        }
                    }
                    
                    // Deactivate tool after successful generation
                    activeTools.delete('image-generation');
                    imageGenToolBtn.classList.remove('active');
                    
                } else {
                    addMessage(`‚ùå **L·ªói t·∫°o ·∫£nh:** ${imageData.error || 'Kh√¥ng r√µ nguy√™n nh√¢n'}`, false, model, context, formatTimestamp(new Date()));
                }
                
            } catch (error) {
                console.error('Error in image generation:', error);
                addMessage(`‚ùå **L·ªói:** ${error.message}`, false, model, context, formatTimestamp(new Date()));
            } finally {
                loading.classList.remove('active');
                sendBtn.disabled = false;
                messageInput.focus();
            }
        }
        
        // Global variables to store Lora and VAE lists
        let availableLoras = [];
        let availableVaes = [];
        
        async function loadSamplers() {
            try {
                const response = await fetch('/api/sd-samplers');
                const data = await response.json();
                
                const select = document.getElementById('samplerSelect');
                select.innerHTML = '';
                
                data.samplers.forEach(sampler => {
                    const option = document.createElement('option');
                    option.value = sampler;
                    option.textContent = sampler;
                    select.appendChild(option);
                });
                
                // Set default
                select.value = 'DPM++ 2M Karras';
                
            } catch (error) {
                console.error('Error loading samplers:', error);
            }
        }
        
        async function loadLoras() {
            try {
                const response = await fetch('/api/sd-loras');
                const data = await response.json();
                availableLoras = data.loras || [];
                console.log(`Loaded ${availableLoras.length} Lora models`);
            } catch (error) {
                console.error('Error loading loras:', error);
                availableLoras = [];
            }
        }
        
        async function loadVaes() {
            try {
                const response = await fetch('/api/sd-vaes');
                const data = await response.json();
                availableVaes = data.vaes || [];
                
                // Populate VAE selects
                const vaeSelect = document.getElementById('vaeSelect');
                const img2imgVaeSelect = document.getElementById('img2imgVaeSelect');
                
                [vaeSelect, img2imgVaeSelect].forEach(select => {
                    select.innerHTML = '<option value="">Automatic (M·∫∑c ƒë·ªãnh)</option>';
                    availableVaes.forEach(vae => {
                        const option = document.createElement('option');
                        option.value = vae.model_name || vae;
                        option.textContent = vae.model_name || vae;
                        select.appendChild(option);
                    });
                });
                
                console.log(`Loaded ${availableVaes.length} VAE models`);
            } catch (error) {
                console.error('Error loading VAEs:', error);
                availableVaes = [];
            }
        }
        
        // Counter for unique Lora selection IDs
        let loraIdCounter = 0;
        
        function addLoraSelection() {
            const container = document.getElementById('loraSelectionContainer');
            const loraId = ++loraIdCounter;
            
            const loraDiv = document.createElement('div');
            loraDiv.id = `lora-${loraId}`;
            loraDiv.style.cssText = 'display: flex; gap: 10px; align-items: center; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 4px;';
            
            const selectHTML = `
                <select id="loraName-${loraId}" style="flex: 2;">
                    <option value="">-- Ch·ªçn Lora --</option>
                    ${availableLoras.map(lora => `<option value="${lora.name || lora.alias}">${lora.alias || lora.name}</option>`).join('')}
                </select>
                <input type="number" id="loraWeight-${loraId}" placeholder="Weight" value="1.0" min="0" max="2" step="0.1" style="flex: 1;">
                <button type="button" onclick="removeLoraSelection(${loraId})" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚ùå</button>
            `;
            
            loraDiv.innerHTML = selectHTML;
            container.insertBefore(loraDiv, document.getElementById('addLoraBtn'));
        }
        
        function removeLoraSelection(loraId) {
            const loraDiv = document.getElementById(`lora-${loraId}`);
            if (loraDiv) loraDiv.remove();
        }
        
        function addImg2imgLoraSelection() {
            const container = document.getElementById('img2imgLoraSelectionContainer');
            const loraId = ++loraIdCounter;
            
            const loraDiv = document.createElement('div');
            loraDiv.id = `img2imgLora-${loraId}`;
            loraDiv.style.cssText = 'display: flex; gap: 10px; align-items: center; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 4px;';
            
            const selectHTML = `
                <select id="img2imgLoraName-${loraId}" style="flex: 2;">
                    <option value="">-- Ch·ªçn Lora --</option>
                    ${availableLoras.map(lora => `<option value="${lora.name || lora.alias}">${lora.alias || lora.name}</option>`).join('')}
                </select>
                <input type="number" id="img2imgLoraWeight-${loraId}" placeholder="Weight" value="1.0" min="0" max="2" step="0.1" style="flex: 1;">
                <button type="button" onclick="removeImg2imgLoraSelection(${loraId})" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚ùå</button>
            `;
            
            loraDiv.innerHTML = selectHTML;
            container.insertBefore(loraDiv, document.getElementById('addImg2imgLoraBtn'));
        }
        
        function removeImg2imgLoraSelection(loraId) {
            const loraDiv = document.getElementById(`img2imgLora-${loraId}`);
            if (loraDiv) loraDiv.remove();
        }
        
        function getSelectedLoras() {
            const loras = [];
            const container = document.getElementById('loraSelectionContainer');
            const loraElements = container.querySelectorAll('[id^="lora-"]');
            
            loraElements.forEach(elem => {
                const id = elem.id.split('-')[1];
                const name = document.getElementById(`loraName-${id}`)?.value;
                const weight = parseFloat(document.getElementById(`loraWeight-${id}`)?.value || 1.0);
                
                if (name) {
                    loras.push({ name, weight });
                }
            });
            
            return loras;
        }
        
        function getImg2imgSelectedLoras() {
            const loras = [];
            const container = document.getElementById('img2imgLoraSelectionContainer');
            const loraElements = container.querySelectorAll('[id^="img2imgLora-"]');
            
            loraElements.forEach(elem => {
                const id = elem.id.split('-')[1];
                const name = document.getElementById(`img2imgLoraName-${id}`)?.value;
                const weight = parseFloat(document.getElementById(`img2imgLoraWeight-${id}`)?.value || 1.0);
                
                if (name) {
                    loras.push({ name, weight });
                }
            });
            
            return loras;
        }
        
        // Auto-adjust steps and CFG based on image size
        function adjustStepsAndCFG() {
            const width = parseInt(document.getElementById('imageWidth').value);
            const height = parseInt(document.getElementById('imageHeight').value);
            const stepsInput = document.getElementById('imageSteps');
            const cfgInput = document.getElementById('cfgScale');
            const stepsLabel = document.getElementById('stepsLabel');
            const cfgLabel = document.getElementById('cfgLabel');
            
            // Calculate max dimension and megapixels
            const maxDim = Math.max(width, height);
            const megapixels = (width * height) / 1_000_000;
            
            // Warning for 4K images
            if (megapixels >= 4) {
                const currentSteps = parseInt(stepsInput.value);
                const estimatedTime = Math.ceil((currentSteps * (2 + megapixels * 1.5)) / 60);
                
                alert(`‚ö†Ô∏è C·∫¢NH B√ÅO 4K:\n\n` +
                      `K√≠ch th∆∞·ªõc ${width}x${height} (${megapixels.toFixed(1)}MP) v·ªõi ${currentSteps} steps\n` +
                      `Th·ªùi gian ∆∞·ªõc t√≠nh: ${estimatedTime} ph√∫t\n\n` +
                      `L∆∞u √Ω:\n` +
                      `- Kh√¥ng c√≥ timeout - s·∫Ω ch·ªù cho ƒë·∫øn khi ho√†n t·∫•t\n` +
                      `- B·∫°n c√≥ th·ªÉ cancel request b·∫±ng c√°ch refresh trang\n` +
                      `- Ho·∫∑c gi·∫£m steps xu·ªëng 30-40 ƒë·ªÉ nhanh h∆°n\n` +
                      `- ƒê·∫£m b·∫£o GPU c√≥ ƒë·ªß VRAM (c·∫ßn ~8GB)`);
            }
            
            // If size >= 1440, enforce minimum steps=50, cfg=12
            if (maxDim >= 1440) {
                // Update minimum values
                const currentSteps = parseInt(stepsInput.value);
                const currentCfg = parseFloat(cfgInput.value);
                
                if (currentSteps < 50) {
                    stepsInput.value = 50;
                }
                if (currentCfg < 12) {
                    cfgInput.value = 12;
                }
                
                // Update labels with time warning
                stepsLabel.textContent = `(T·ªëi thi·ªÉu 50 cho HD/4K - ~${Math.ceil(megapixels * 2)}min)`;
                stepsLabel.style.color = '#ff9800';
                cfgLabel.textContent = '(T·ªëi thi·ªÉu 12 cho HD/4K)';
                cfgLabel.style.color = '#ff9800';
                
                // Set minimum attributes
                stepsInput.min = 50;
                cfgInput.min = 12;
            } else {
                // Reset to default for smaller sizes
                stepsLabel.textContent = '(20-50 khuy·∫øn ngh·ªã)';
                stepsLabel.style.color = '';
                cfgLabel.textContent = '(7-12 khuy·∫øn ngh·ªã)';
                cfgLabel.style.color = '';
                
                stepsInput.min = 1;
                cfgInput.min = 1;
            }
        }
        
        async function generateImage() {
            const btn = document.getElementById('generateImageBtn');
            const container = document.getElementById('generatedImageContainer');
            
            console.log('generateImage called');
            
            // Get form values
            const params = {
                prompt: document.getElementById('imagePrompt').value,
                negative_prompt: document.getElementById('negativePrompt').value,
                width: parseInt(document.getElementById('imageWidth').value),
                height: parseInt(document.getElementById('imageHeight').value),
                steps: parseInt(document.getElementById('imageSteps').value),
                cfg_scale: parseFloat(document.getElementById('cfgScale').value),
                sampler_name: document.getElementById('samplerSelect').value,
                restore_faces: document.getElementById('restoreFaces').checked,
                enable_hr: document.getElementById('enableHR').checked,
                seed: -1,
                lora_models: getSelectedLoras(),
                vae: document.getElementById('vaeSelect').value || null
            };
            
            console.log('Params:', params);
            
            if (!params.prompt) {
                alert('Vui l√≤ng nh·∫≠p prompt!');
                return;
            }
            
            // Disable button and show loading
            btn.disabled = true;
            btn.textContent = '‚è≥ ƒêang t·∫°o ·∫£nh...';
            container.style.display = 'none';
            
            try {
                console.log('Sending request to /api/generate-image');
                const response = await fetch('/api/generate-image', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(params)
                });
                
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);
                
                if (data.success && data.images && data.images.length > 0) {
                    // Save image to server first
                    currentGeneratedImage = data.images[0];
                    
                    try {
                        const saveResponse = await fetch('/api/save-image', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({
                                image: currentGeneratedImage,
                                metadata: {
                                    prompt: params.prompt,
                                    negative_prompt: params.negative_prompt,
                                    width: params.width,
                                    height: params.height,
                                    steps: params.steps,
                                    cfg_scale: params.cfg_scale,
                                    sampler_name: params.sampler_name
                                }
                            })
                        });
                        
                        const saveData = await saveResponse.json();
                        console.log('Image saved:', saveData);
                        
                        if (saveData.success) {
                            // Use server URL instead of base64
                            const imageUrl = saveData.url;
                            
                            // Display image in modal
                            const img = document.getElementById('generatedImage');
                            img.src = imageUrl;
                            container.style.display = 'block';
                            
                            // Auto-add to chat conversation with server URL
                            const timestamp = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
                            const imageHtml = `
                                <div class="message assistant-message">
                                    <div class="message-header">
                                        <strong>üé® ·∫¢nh ƒë∆∞·ª£c t·∫°o</strong>
                                        <span class="timestamp">${timestamp}</span>
                                    </div>
                                    <div class="message-content">
                                        <img src="${imageUrl}" alt="Generated Image" style="max-width: 100%; border-radius: 8px; margin: 10px 0;" loading="lazy">
                                        <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50; border-radius: 4px;">
                                            <strong>üìù Prompt:</strong> ${params.prompt}<br>
                                            ${params.negative_prompt ? `<strong>‚ùå Negative:</strong> ${params.negative_prompt}<br>` : ''}
                                            <strong>üñºÔ∏è Size:</strong> ${params.width}x${params.height} | <strong>Steps:</strong> ${params.steps} | <strong>CFG:</strong> ${params.cfg_scale}<br>
                                            <strong>üé≤ Sampler:</strong> ${params.sampler_name}<br>
                                            <strong>üíæ Saved:</strong> ${saveData.filename}
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            // Add to chat
                            const chatMessages = document.getElementById('chatContainer');
                            if (chatMessages) {
                                chatMessages.insertAdjacentHTML('beforeend', imageHtml);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                                
                                // Save to current chat session immediately
                                if (currentChatId && chatSessions[currentChatId]) {
                                    chatSessions[currentChatId].messages = Array.from(chatMessages.children).map(el => el.outerHTML);
                                    chatSessions[currentChatId].updatedAt = new Date();
                                    saveSessions();
                                }
                            }
                        }
                    } catch (saveError) {
                        console.error('Error saving image to server:', saveError);
                        // Fallback: Use base64 if save fails
                        const img = document.getElementById('generatedImage');
                        img.src = 'data:image/png;base64,' + currentGeneratedImage;
                        container.style.display = 'block';
                    }
                    
                    btn.textContent = '‚úÖ ·∫¢nh ƒë√£ t·∫°o xong!';
                    setTimeout(() => {
                        btn.textContent = 'üé® T·∫°o ·∫£nh';
                    }, 2000);
                } else {
                    console.error('Failed to generate image:', data);
                    alert('L·ªói: ' + (data.error || 'Kh√¥ng th·ªÉ t·∫°o ·∫£nh'));
                    btn.textContent = 'üé® T·∫°o ·∫£nh';
                }
                
            } catch (error) {
                console.error('Error generating image:', error);
                alert('L·ªói khi t·∫°o ·∫£nh: ' + error.message);
                btn.textContent = 'üé® T·∫°o ·∫£nh';
            } finally {
                console.log('Re-enabling button');
                btn.disabled = false;
            }
        }
        
        function copyImageToChat() {
            if (!currentGeneratedImage) return;
            
            // Add image to chat
            const timestamp = formatTimestamp(new Date());
            const imageHtml = `<img src="data:image/png;base64,${currentGeneratedImage}" style="max-width: 400px; border-radius: 10px; margin-top: 10px;">`;
            
            addMessage(imageHtml, false, 'stable-diffusion', 'image-generation', timestamp);
            
            // Close modal
            closeImageModal();
            
            // Show success message
            alert('·∫¢nh ƒë√£ ƒë∆∞·ª£c th√™m v√†o chat! üé®');
        }
        
        function downloadGeneratedImage() {
            if (!currentGeneratedImage) return;
            
            const link = document.createElement('a');
            link.href = 'data:image/png;base64,' + currentGeneratedImage;
            link.download = `ai-generated-${Date.now()}.png`;
            link.click();
        }
        
        // Add event listener for image gen button
        document.getElementById('imageGenBtn').addEventListener('click', openImageModal);
        
        // Add event listeners for width/height to auto-adjust steps and CFG
        document.getElementById('imageWidth').addEventListener('change', adjustStepsAndCFG);
        document.getElementById('imageHeight').addEventListener('change', adjustStepsAndCFG);
        
        // Add event listener for model select to auto-update
        if (modelSelect) {
            modelSelect.addEventListener('change', async (e) => {
                const selectedModel = e.target.value;
                if (selectedModel) {
                    await changeSDModel(selectedModel);
                }
            });
        }
        
        // Close modal when clicking outside
        document.getElementById('imageGenModal').addEventListener('click', (e) => {
            if (e.target.id === 'imageGenModal') {
                closeImageModal();
            }
        });
    </script>
    
    <!-- Image Preview Modal (Discord-style) -->
    <div id="imagePreviewModal" class="image-preview-modal">
        <div class="image-preview-controls">
            <button class="preview-control-btn" onclick="downloadPreviewImage()" title="Download">
                üì•
            </button>
            <button class="preview-control-btn" onclick="zoomPreviewImage(-0.2)" title="Zoom Out">
                üîç-
            </button>
            <button class="preview-control-btn" onclick="zoomPreviewImage(0.2)" title="Zoom In">
                üîç+
            </button>
            <button class="preview-control-btn" onclick="resetPreviewZoom()" title="Reset Zoom">
                ‚ü≤
            </button>
        </div>
        <span class="image-preview-close" onclick="closeImagePreview()">&times;</span>
        <img id="imagePreviewContent" class="image-preview-content" src="" alt="Preview">
        <div id="imagePreviewInfo" class="image-preview-info"></div>
    </div>
    
    <!-- Message History Modal -->
    <div id="historyModal" class="history-modal">
        <div class="history-modal-content">
            <div class="modal-header">
                <h2>üìú L·ªãch s·ª≠ ch·ªânh s·ª≠a</h2>
                <button onclick="closeHistoryModal()" style="background: #ff4444; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer;">ƒê√≥ng</button>
            </div>
            <div id="historyContent"></div>
        </div>
    </div>
    
    <script>
        // Image Preview Functionality
        let currentPreviewSrc = '';
        
        function openImagePreview(imgElement) {
            console.log('[Image Preview] Opening preview for:', imgElement.src);
            const modal = document.getElementById('imagePreviewModal');
            const previewImg = document.getElementById('imagePreviewContent');
            const previewInfo = document.getElementById('imagePreviewInfo');
            
            if (!modal) {
                console.error('[Image Preview] Modal not found!');
                return;
            }
            
            currentPreviewSrc = imgElement.src;
            previewImg.src = currentPreviewSrc;
            
            // Extract info from image
            const imgAlt = imgElement.alt || 'Image';
            const imgWidth = imgElement.naturalWidth;
            const imgHeight = imgElement.naturalHeight;
            
            previewInfo.innerHTML = `${imgAlt} ‚Ä¢ ${imgWidth} x ${imgHeight}`;
            
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            console.log('[Image Preview] Modal opened successfully');
        }
        
        let currentZoom = 1;
        
        function closeImagePreview() {
            const modal = document.getElementById('imagePreviewModal');
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';
            currentZoom = 1;
            const img = document.getElementById('imagePreviewContent');
            if (img) {
                img.style.transform = 'scale(1)';
            }
        }
        
        function zoomPreviewImage(delta) {
            currentZoom += delta;
            currentZoom = Math.max(0.5, Math.min(currentZoom, 3)); // Limit 0.5x to 3x
            const img = document.getElementById('imagePreviewContent');
            if (img) {
                img.style.transform = `scale(${currentZoom})`;
                img.style.transition = 'transform 0.2s ease';
            }
        }
        
        function resetPreviewZoom() {
            currentZoom = 1;
            const img = document.getElementById('imagePreviewContent');
            if (img) {
                img.style.transform = 'scale(1)';
                img.style.transition = 'transform 0.2s ease';
            }
        }
        
        function downloadPreviewImage() {
            const img = document.getElementById('imagePreviewContent');
            if (!img || !img.src) return;
            
            const link = document.createElement('a');
            link.href = img.src;
            link.download = `image_${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Make all images in chat clickable
        window.makeImagesClickable = function() {
            const images = document.querySelectorAll('.message-content img');
            console.log(`[Image Preview] Found ${images.length} images`);
            images.forEach(img => {
                if (!img.hasAttribute('data-clickable')) {
                    img.setAttribute('data-clickable', 'true');
                    img.style.cursor = 'zoom-in';
                    img.addEventListener('click', function(e) {
                        e.stopPropagation();
                        console.log('[Image Preview] Image clicked:', this.src);
                        openImagePreview(this);
                    });
                    console.log('[Image Preview] Made clickable:', img.src);
                }
            });
        };
        
        // Initialize event listeners after DOM is ready
        function initImagePreview() {
            console.log('[Image Preview] Initializing event listeners...');
            
            // Click on background to close
            const modal = document.getElementById('imagePreviewModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeImagePreview();
                    }
                });
                console.log('[Image Preview] Modal click listener added');
            } else {
                console.error('[Image Preview] Modal not found during init!');
            }
            
            // ESC key to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeImagePreview();
                    closeHistoryModal();
                }
            });
            
            // Mouse wheel zoom on preview image
            const previewImg = document.getElementById('imagePreviewContent');
            if (previewImg) {
                previewImg.addEventListener('wheel', function(e) {
                    if (modal.classList.contains('active')) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        zoomPreviewImage(delta);
                    }
                }, { passive: false });
            }
            
            // Keyboard shortcuts for zoom
            document.addEventListener('keydown', function(e) {
                if (modal.classList.contains('active')) {
                    if (e.key === '+' || e.key === '=') {
                        e.preventDefault();
                        zoomPreviewImage(0.2);
                    } else if (e.key === '-' || e.key === '_') {
                        e.preventDefault();
                        zoomPreviewImage(-0.2);
                    } else if (e.key === '0') {
                        e.preventDefault();
                        resetPreviewZoom();
                    }
                }
            });
            
            // Make existing images clickable
            window.makeImagesClickable();
        }
        
        // Initialize on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initImagePreview);
        } else {
            initImagePreview();
        }
        
        // Message History Functionality
        const messageHistory = new Map(); // messageId -> [version1, version2, ...]
        
        function addMessageVersion(messageId, content, timestamp) {
            if (!messageHistory.has(messageId)) {
                messageHistory.set(messageId, []);
            }
            messageHistory.get(messageId).push({
                content: content,
                timestamp: timestamp || new Date().toISOString()
            });
        }
        
        function showMessageHistory(messageId) {
            const history = messageHistory.get(messageId);
            if (!history || history.length === 0) {
                alert('Kh√¥ng c√≥ l·ªãch s·ª≠ ch·ªânh s·ª≠a');
                return;
            }
            
            const modal = document.getElementById('historyModal');
            const historyContent = document.getElementById('historyContent');
            
            let html = '<div style="margin-bottom: 15px; color: #666;">';
            html += `<p>T·ªïng s·ªë phi√™n b·∫£n: <strong>${history.length + 1}</strong></p>`;
            html += '<p style="font-size: 13px; margin-top: 5px;">üí° B·∫•m "‚Ü©Ô∏è Kh√¥i ph·ª•c" ƒë·ªÉ quay l·∫°i phi√™n b·∫£n c≈© v√† ti·∫øp t·ª•c chat</p>';
            html += '</div>';
            
            // Show current version first
            const currentMessage = document.querySelector(`[data-message-id="${messageId}"]`);
            if (currentMessage) {
                const currentContent = currentMessage.querySelector('.message-text')?.textContent || '';
                html += '<div class="history-version current">';
                html += '<div class="history-version-header">‚úÖ Phi√™n b·∫£n hi·ªán t·∫°i</div>';
                html += `<div style="white-space: pre-wrap; padding: 10px 0;">${currentContent}</div>`;
                html += '</div>';
            }
            
            // Show all previous versions in reverse order (newest first)
            const reversedHistory = [...history].reverse();
            reversedHistory.forEach((version, index) => {
                const versionNumber = history.length - index;
                html += '<div class="history-version">';
                html += `<div class="history-version-header">`;
                html += `üìù Phi√™n b·∫£n ${versionNumber} - ${new Date(version.timestamp).toLocaleString('vi-VN')}`;
                html += `</div>`;
                html += `<div style="white-space: pre-wrap; padding: 10px 0;">${version.content}</div>`;
                html += `<div style="margin-top: 10px;">`;
                html += `<button onclick="restoreVersion('${messageId}', ${history.length - index - 1})" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 14px;">`;
                html += `‚Ü©Ô∏è Kh√¥i ph·ª•c & Chat t·ª´ ƒë√¢y`;
                html += `</button>`;
                html += `</div>`;
                html += '</div>';
            });
            
            historyContent.innerHTML = html;
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        // Restore a previous version and allow branching from there
        async function restoreVersion(messageId, versionIndex) {
            const history = messageHistory.get(messageId);
            if (!history || !history[versionIndex]) {
                alert('Kh√¥ng t√¨m th·∫•y phi√™n b·∫£n n√†y');
                return;
            }
            
            const version = history[versionIndex];
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            
            if (!messageDiv) {
                alert('Kh√¥ng t√¨m th·∫•y tin nh·∫Øn');
                return;
            }
            
            // Confirm restore
            const versionNumber = versionIndex + 1;
            const confirm = window.confirm(
                `B·∫°n c√≥ ch·∫Øc mu·ªën kh√¥i ph·ª•c Phi√™n b·∫£n ${versionNumber}?\n\n` +
                `N·ªôi dung: "${version.content.substring(0, 100)}${version.content.length > 100 ? '...' : ''}"\n\n` +
                `T·∫•t c·∫£ tin nh·∫Øn sau tin nh·∫Øn n√†y s·∫Ω b·ªã x√≥a v√† AI s·∫Ω t·∫°o response m·ªõi.`
            );
            
            if (!confirm) return;
            
            // Close history modal
            closeHistoryModal();
            
            // Save current content to history before restoring
            const currentText = messageDiv.querySelector('.message-text')?.textContent || '';
            addMessageVersion(messageId, currentText, new Date().toISOString());
            
            // Get all messages before this one
            const allMessages = Array.from(chatContainer.children);
            const messageIndex = allMessages.indexOf(messageDiv);
            
            // Build conversation history up to this point
            const historyBeforeEdit = [];
            for (let i = 0; i < messageIndex; i++) {
                const msg = allMessages[i];
                const isUser = msg.classList.contains('user');
                const textContent = msg.querySelector('.message-text')?.textContent || '';
                
                historyBeforeEdit.push({
                    role: isUser ? 'user' : 'assistant',
                    content: textContent
                });
            }
            
            // Update the message text with restored version
            const textDiv = messageDiv.querySelector('.message-text');
            textDiv.textContent = version.content;
            
            // Remove all messages after this one
            for (let i = allMessages.length - 1; i > messageIndex; i--) {
                allMessages[i].remove();
            }
            
            // Get model and context from message data or use current settings
            const model = messageDiv.dataset.model || modelSelect.value;
            const context = messageDiv.dataset.context || contextSelect.value;
            const deepThinking = deepThinkingCheck.checked;
            
            // Show loading
            loading.classList.add('active');
            sendBtn.disabled = true;
            
            try {
                // Call backend to regenerate response with restored input
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: version.content,
                        model: model,
                        context: context,
                        deep_thinking: deepThinking,
                        tools: [],
                        history: historyBeforeEdit
                    })
                });
                
                const data = await response.json();
                const responseTimestamp = formatTimestamp(new Date());
                
                if (data.error) {
                    addMessage(`‚ùå L·ªói: ${data.error}`, false, model, context, responseTimestamp);
                } else {
                    addMessage(data.response, false, model, context, responseTimestamp);
                }
                
                // Update chat session
                if (currentChatId && chatSessions[currentChatId]) {
                    chatSessions[currentChatId].messages = Array.from(chatContainer.children).map(el => el.outerHTML);
                    chatSessions[currentChatId].updatedAt = new Date();
                    saveSessions();
                    renderChatList();
                }
                
            } catch (error) {
                console.error('Error restoring version:', error);
                addMessage(`‚ùå L·ªói khi kh√¥i ph·ª•c: ${error.message}`, false, model, context, formatTimestamp(new Date()));
            } finally {
                loading.classList.remove('active');
                sendBtn.disabled = false;
            }
        }
        
        function closeHistoryModal() {
            const modal = document.getElementById('historyModal');
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Click outside to close history modal
        document.getElementById('historyModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeHistoryModal();
            }
        });
    </script>
</body>
</html>
